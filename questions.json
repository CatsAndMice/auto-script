[
    {
        "id": 1,
        "title": "1. 输出是什么？",
        "result": "答案: D",
        "code": "function sayHi() {\n  console.log(name)\n  console.log(age)\n  var name = 'Lydia'\n  let age = 21\n}\n\nsayHi()\n",
        "answer": "在函数内部，我们首先通过 `var` 关键字声明了 `name` 变量。这意味着变量被提升了（内存空间在创建阶段就被设置好了），直到程序运行到定义变量位置之前默认值都是 `undefined`。因为当我们打印 `name` 变量时还没有执行到定义变量的位置，因此变量的值保持为 `undefined`。\n通过 `let` 和 `const` 关键字声明的变量也会提升，但是和 `var` 不同，它们不会被&lt;i&gt;初始化&lt;/i&gt;。在我们声明（初始化）之前是不能访问它们的。这个行为被称之为暂时性死区。当我们试图在声明之前访问它们时，JavaScript 将会抛出一个 `ReferenceError` 错误。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `Lydia` 和 `undefined`"
            },
            {
                "key": "B",
                "value": "B: `Lydia` 和 `ReferenceError`"
            },
            {
                "key": "C",
                "value": "C: `ReferenceError` 和 `21`"
            },
            {
                "key": "D",
                "value": "D: `undefined` 和 `ReferenceError`"
            }
        ]
    },
    {
        "id": 2,
        "title": "2. 输出是什么？",
        "result": "答案: C",
        "code": "for (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1)\n}\n\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1)\n}\n",
        "answer": "由于 JavaScript 的事件循环，`setTimeout` 回调会在**遍历结束后**才执行。因为在第一个遍历中遍历 `i` 是通过 `var` 关键字声明的，所以这个值是全局作用域下的。在遍历过程中，我们通过一元操作符 `++` 来每次递增 `i` 的值。当 `setTimeout` 回调执行的时候，`i` 的值等于 3。\n在第二个遍历中，遍历 `i` 是通过 `let` 关键字声明的：通过 `let` 和 `const` 关键字声明的变量是拥有块级作用域（指的是任何在 {} 中的内容）。在每次的遍历过程中，`i` 都有一个新值，并且每个值都在循环内的作用域中。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `0 1 2` 和 `0 1 2`"
            },
            {
                "key": "B",
                "value": "B: `0 1 2` 和 `3 3 3`"
            },
            {
                "key": "C",
                "value": "C: `3 3 3` 和 `0 1 2`"
            }
        ]
    },
    {
        "id": 3,
        "title": "3. 输出是什么？",
        "result": "答案: B",
        "code": "const shape = {\n  radius: 10,\n  diameter() {\n    return this.radius * 2\n  },\n  perimeter: () => 2 * Math.PI * this.radius\n}\n\nshape.diameter()\nshape.perimeter()\n",
        "answer": "注意 `diameter` 的值是一个常规函数，但是 `perimeter` 的值是一个箭头函数。\n对于箭头函数，`this` 关键字指向的是它当前周围作用域（简单来说是包含箭头函数的常规函数，如果没有常规函数的话就是全局对象），这个行为和常规函数不同。这意味着当我们调用 `perimeter` 时，`this` 不是指向 `shape` 对象，而是它的周围作用域（在例子中是 `window`）。\n在 `window` 中没有 `radius` 这个属性，因此返回 `undefined`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `20` and `62.83185307179586`"
            },
            {
                "key": "B",
                "value": "B: `20` and `NaN`"
            },
            {
                "key": "C",
                "value": "C: `20` and `63`"
            },
            {
                "key": "D",
                "value": "D: `NaN` and `63`"
            }
        ]
    },
    {
        "id": 4,
        "title": "4. 输出是什么？",
        "result": "答案: A",
        "code": "+true;\n!\"Lydia\";\n",
        "answer": "一元操作符加号尝试将 bool 转为 number。`true` 转换为 number 的话为 `1`，`false` 为 `0`。\n字符串 `'Lydia'` 是一个真值，真值取反那么就返回 `false`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `1` and `false`"
            },
            {
                "key": "B",
                "value": "B: `false` and `NaN`"
            },
            {
                "key": "C",
                "value": "C: `false` and `false`"
            }
        ]
    },
    {
        "id": 5,
        "title": "5. 哪一个是正确的？",
        "result": "答案: A",
        "code": "const bird = {\n  size: 'small'\n}\n\nconst mouse = {\n  name: 'Mickey',\n  small: true\n}\n",
        "answer": "在 JavaScript 中，所有对象的 keys 都是字符串（除非对象是 Symbol）。尽管我们可能不会定义它们为字符串，但它们在底层总会被转换为字符串。\n当我们使用括号语法时（[]），JavaScript 会解释（或者 unboxes）语句。它首先看到第一个开始括号 `[` 并继续前进直到找到结束括号 `]`。只有这样，它才会计算语句的值。\n`mouse[bird.size]`：首先计算 `bird.size`，这会得到 `small`。`mouse[\"small\"]` 返回 `true`。\n然后使用点语法的话，上面这一切都不会发生。`mouse` 没有 `bird` 这个 key，这也就意味着 `mouse.bird` 是 `undefined`。然后当我们使用点语法 `mouse.bird.size` 时，因为 `mouse.bird` 是 `undefined`，这也就变成了 `undefined.size`。这个行为是无效的，并且会抛出一个错误类似 `Cannot read property \"size\" of undefined`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `mouse.bird.size`是无效的"
            },
            {
                "key": "B",
                "value": "B: `mouse[bird.size]`是无效的"
            },
            {
                "key": "C",
                "value": "C: `mouse[bird[\"size\"]]`是无效的"
            },
            {
                "key": "D",
                "value": "D: 以上三个选项都是有效的"
            }
        ]
    },
    {
        "id": 6,
        "title": "6. 输出是什么？",
        "result": "答案: A",
        "code": "let c = { greeting: 'Hey!' }\nlet d\n\nd = c\nc.greeting = 'Hello'\nconsole.log(d.greeting)\n",
        "answer": "在 JavaScript 中，当设置两个对象彼此相等时，它们会通过**引用**进行交互。\n首先，变量 `c` 的值是一个对象。接下来，我们给 `d` 分配了一个和 `c` 对象相同的引用。\n&lt;img src=\"https://i.imgur.com/ko5k0fs.png\" width=\"200\"&gt;\n因此当我们改变其中一个对象时，其实是改变了所有的对象。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `Hello`"
            },
            {
                "key": "B",
                "value": "B: `undefined`"
            },
            {
                "key": "C",
                "value": "C: `ReferenceError`"
            },
            {
                "key": "D",
                "value": "D: `TypeError`"
            }
        ]
    },
    {
        "id": 7,
        "title": "7. 输出是什么？",
        "result": "答案: C",
        "code": "let a = 3\nlet b = new Number(3)\nlet c = 3\n\nconsole.log(a == b)\nconsole.log(a === b)\nconsole.log(b === c)\n",
        "answer": "`new Number()` 是一个内建的函数构造器。虽然它看着像是一个 number，但它实际上并不是一个真实的 number：它有一堆额外的功能并且它是一个对象。\n当我们使用 `==` 操作符时，它只会检查两者是否拥有相同的**值**。因为它们的值都是 `3`，因此返回 `true`。\n然后，当我们使用 `===` 操作符时，两者的值以及**类型**都应该是相同的。`new Number()` 是一个对象而不是 number，因此返回 `false`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `true` `false` `true`"
            },
            {
                "key": "B",
                "value": "B: `false` `false` `true`"
            },
            {
                "key": "C",
                "value": "C: `true` `false` `false`"
            },
            {
                "key": "D",
                "value": "D: `false` `true` `true`"
            }
        ]
    },
    {
        "id": 8,
        "title": "8. 输出是什么？",
        "result": "答案: D",
        "code": "class Chameleon {\n  static colorChange(newColor) {\n    this.newColor = newColor\n    return this.newColor\n  }\n\n  constructor({ newColor = 'green' } = {}) {\n    this.newColor = newColor\n  }\n}\n\nconst freddie = new Chameleon({ newColor: 'purple' })\nfreddie.colorChange('orange')\n",
        "answer": "`colorChange` 是一个静态方法。静态方法被设计为只能被创建它们的构造器使用（也就是 `Chameleon`），并且不能传递给实例。因为 `freddie` 是一个实例，静态方法不能被实例使用，因此抛出了 `TypeError` 错误。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `orange`"
            },
            {
                "key": "B",
                "value": "B: `purple`"
            },
            {
                "key": "C",
                "value": "C: `green`"
            },
            {
                "key": "D",
                "value": "D: `TypeError`"
            }
        ]
    },
    {
        "id": 9,
        "title": "9. 输出是什么？",
        "result": "答案: A",
        "code": "let greeting\ngreetign = {} // Typo!\nconsole.log(greetign)\n",
        "answer": "代码打印出了一个对象，这是因为我们在全局对象上创建了一个空对象！当我们将 `greeting` 写错成 `greetign` 时，JS 解释器实际在上浏览器中将它视为 `global.greetign = {}`（或者 `window.greetign = {}`）。\n为了避免这个为题，我们可以使用 `\"use strict\"。这能确保当你声明变量时必须赋值。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `{}`"
            },
            {
                "key": "B",
                "value": "B: `ReferenceError: greetign is not defined`"
            },
            {
                "key": "C",
                "value": "C: `undefined`"
            }
        ]
    },
    {
        "id": 10,
        "title": "10. 当我们这么做时，会发生什么？",
        "result": "答案: A",
        "code": "function bark() {\n  console.log('Woof!')\n}\n\nbark.animal = 'dog'\n",
        "answer": "这在 JavaScript 中是可以的，因为函数是对象！（除了基本类型之外其他都是对象）\n函数是一个特殊的对象。你写的这个代码其实不是一个实际的函数。函数是一个拥有属性的对象，并且属性也可被调用。\n",
        "options": [
            {
                "key": "A",
                "value": "A: 正常运行！"
            },
            {
                "key": "B",
                "value": "B: `SyntaxError`. 你不能通过这种方式给函数增加属性。"
            },
            {
                "key": "C",
                "value": "C: `undefined`"
            },
            {
                "key": "D",
                "value": "D: `ReferenceError`"
            }
        ]
    },
    {
        "id": 11,
        "title": "11. 输出是什么？",
        "result": "答案: A",
        "code": "function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst member = new Person(\"Lydia\", \"Hallie\");\nPerson.getFullName = function () {\n  return `${this.firstName} ${this.lastName}`;\n}\n\nconsole.log(member.getFullName());\n",
        "answer": "你不能像常规对象那样，给构造函数添加属性。如果你想一次性给所有实例添加特性，你应该使用原型。因此本例中，使用如下方式：\n这才会使 `member.getFullName()` 起作用。为什么这么做有益的？假设我们将这个方法添加到构造函数本身里。也许不是每个 `Person` 实例都需要这个方法。这将浪费大量内存空间，因为它们仍然具有该属性，这将占用每个实例的内存空间。相反，如果我们只将它添加到原型中，那么它只存在于内存中的一个位置，但是所有实例都可以访问它！\n",
        "options": [
            {
                "key": "A",
                "value": "A: `TypeError`"
            },
            {
                "key": "B",
                "value": "B: `SyntaxError`"
            },
            {
                "key": "C",
                "value": "C: `Lydia Hallie`"
            },
            {
                "key": "D",
                "value": "D: `undefined` `undefined`"
            }
        ]
    },
    {
        "id": 12,
        "title": "12. 输出是什么？",
        "result": "答案: A",
        "code": "function Person(firstName, lastName) {\n  this.firstName = firstName\n  this.lastName = lastName\n}\n\nconst lydia = new Person('Lydia', 'Hallie')\nconst sarah = Person('Sarah', 'Smith')\n\nconsole.log(lydia)\nconsole.log(sarah)\n",
        "answer": "对于 `sarah`，我们没有使用 `new` 关键字。当使用 `new` 时，`this` 引用我们创建的空对象。当未使用 `new` 时，`this` 引用的是<strong>全局对象</strong>（global object）。\n我们说 `this.firstName` 等于 `\"Sarah\"`，并且 `this.lastName` 等于 `\"Smith\"`。实际上我们做的是，定义了 `global.firstName = 'Sarah'` 和 `global.lastName = 'Smith'`。而 `sarah` 本身是 `undefined`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `Person {firstName: \"Lydia\", lastName: \"Hallie\"}` and `undefined`"
            },
            {
                "key": "B",
                "value": "B: `Person {firstName: \"Lydia\", lastName: \"Hallie\"}` and `Person {firstName: \"Sarah\", lastName: \"Smith\"}`"
            },
            {
                "key": "C",
                "value": "C: `Person {firstName: \"Lydia\", lastName: \"Hallie\"}` and `{}`"
            },
            {
                "key": "D",
                "value": "D:`Person {firstName: \"Lydia\", lastName: \"Hallie\"}` and `ReferenceError`"
            }
        ]
    },
    {
        "id": 13,
        "title": "13. 事件传播的三个阶段是什么？",
        "result": "答案: D",
        "code": "",
        "answer": "在<strong>捕获</strong>（capturing）阶段中，事件从祖先元素向下传播到目标元素。当事件达到<strong>目标</strong>（target）元素后，<strong>冒泡</strong>（bubbling）才开始。\n&lt;img src=\"https://i.imgur.com/N18oRgd.png\" width=\"200\"&gt;\n",
        "options": [
            {
                "key": "A",
                "value": "A: Target &gt; Capturing &gt; Bubbling"
            },
            {
                "key": "B",
                "value": "B: Bubbling &gt; Target &gt; Capturing"
            },
            {
                "key": "C",
                "value": "C: Target &gt; Bubbling &gt; Capturing"
            },
            {
                "key": "D",
                "value": "D: Capturing &gt; Target &gt; Bubbling"
            }
        ]
    },
    {
        "id": 14,
        "title": "14. 所有对象都有原型。",
        "result": "答案: B",
        "code": "",
        "answer": "除了<strong>基本对象</strong>（base object），所有对象都有原型。基本对象可以访问一些方法和属性，比如 `.toString`。这就是为什么你可以使用内置的 JavaScript 方法！所有这些方法在原型上都是可用的。虽然 JavaScript 不能直接在对象上找到这些方法，但 JavaScript 会沿着原型链找到它们，以便于你使用。\n",
        "options": [
            {
                "key": "A",
                "value": "A: 对"
            },
            {
                "key": "B",
                "value": "B: 错"
            }
        ]
    },
    {
        "id": 15,
        "title": "15. 输出是什么？",
        "result": "答案: C",
        "code": "function sum(a, b) {\n  return a + b\n}\n\nsum(1, '2')\n",
        "answer": "JavaScript 是一种<strong>动态类型语言</strong>：我们不指定某些变量的类型。值可以在你不知道的情况下自动转换成另一种类型，这种类型称为<strong>隐式类型转换</strong>（implicit type coercion）。<strong>Coercion</strong> 是指将一种类型转换为另一种类型。\n在本例中，JavaScript 将数字 `1` 转换为字符串，以便函数有意义并返回一个值。在数字类型（`1`）和字符串类型（`'2'`）相加时，该数字被视为字符串。我们可以连接字符串，比如 `\"Hello\" + \"World\"`，这里发生的是 `\"1\" + \"2\"`，它返回 `\"12\"`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `NaN`"
            },
            {
                "key": "B",
                "value": "B: `TypeError`"
            },
            {
                "key": "C",
                "value": "C: `\"12\"`"
            },
            {
                "key": "D",
                "value": "D: `3`"
            }
        ]
    },
    {
        "id": 16,
        "title": "16. 输出是什么？",
        "result": "答案: C",
        "code": "let number = 0\nconsole.log(number++)\nconsole.log(++number)\nconsole.log(number)\n",
        "answer": "一元<strong>后自增</strong>运算符 `++`：\n一元<strong>前自增</strong>运算符 `++`：\n结果是 `0 2 2`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `1` `1` `2`"
            },
            {
                "key": "B",
                "value": "B: `1` `2` `2`"
            },
            {
                "key": "C",
                "value": "C: `0` `2` `2`"
            },
            {
                "key": "D",
                "value": "D: `0` `1` `2`"
            }
        ]
    },
    {
        "id": 17,
        "title": "17. 输出是什么？",
        "result": "答案: B",
        "code": "function getPersonInfo(one, two, three) {\n  console.log(one)\n  console.log(two)\n  console.log(three)\n}\n\nconst person = 'Lydia'\nconst age = 21\n\ngetPersonInfo`${person} is ${age} years old`\n",
        "answer": "如果使用标记模板字面量，第一个参数的值总是包含字符串的数组。其余的参数获取的是传递的表达式的值！\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"Lydia\"` `21` `[\"\", \" is \", \" years old\"]`"
            },
            {
                "key": "B",
                "value": "B: `[\"\", \" is \", \" years old\"]` `\"Lydia\"` `21`"
            },
            {
                "key": "C",
                "value": "C: `\"Lydia\"` `[\"\", \" is \", \" years old\"]` `21`"
            }
        ]
    },
    {
        "id": 18,
        "title": "18. 输出是什么？",
        "result": "答案: C",
        "code": "function checkAge(data) {\n  if (data === { age: 18 }) {\n    console.log('You are an adult!')\n  } else if (data == { age: 18 }) {\n    console.log('You are still an adult.')\n  } else {\n    console.log(`Hmm.. You don't have an age I guess`)\n  }\n}\n\ncheckAge({ age: 18 })\n",
        "answer": "在测试相等性时，基本类型通过它们的值（value）进行比较，而对象通过它们的引用（reference）进行比较。JavaScript 检查对象是否具有对内存中相同位置的引用。\n题目中我们正在比较的两个对象不是同一个引用：作为参数传递的对象引用的内存位置，与用于判断相等的对象所引用的内存位置并不同。\n这也是 `{ age: 18 } === { age: 18 }` 和 `{ age: 18 } == { age: 18 }` 都返回 `false` 的原因。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `You are an adult!`"
            },
            {
                "key": "B",
                "value": "B: `You are still an adult.`"
            },
            {
                "key": "C",
                "value": "C: `Hmm.. You don't have an age I guess`"
            }
        ]
    },
    {
        "id": 19,
        "title": "19. 输出是什么？",
        "result": "答案: C",
        "code": "function getAge(...args) {\n  console.log(typeof args)\n}\n\ngetAge(21)\n",
        "answer": "扩展运算符（`...args`）会返回实参组成的数组。而数组是对象，因此 `typeof args` 返回 `\"object\"`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"number\"`"
            },
            {
                "key": "B",
                "value": "B: `\"array\"`"
            },
            {
                "key": "C",
                "value": "C: `\"object\"`"
            },
            {
                "key": "D",
                "value": "D: `\"NaN\"`"
            }
        ]
    },
    {
        "id": 20,
        "title": "20. 输出是什么？",
        "result": "答案: C",
        "code": "function getAge() {\n  'use strict'\n  age = 21\n  console.log(age)\n}\n\ngetAge()\n",
        "answer": "使用 `\"use strict\"`，你可以确保不会意外地声明全局变量。我们从来没有声明变量 `age`，因为我们使用 `\"use strict\"`，它将抛出一个引用错误。如果我们不使用 `\"use strict\"`，它就会工作，因为属性 `age` 会被添加到全局对象中了。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `21`"
            },
            {
                "key": "B",
                "value": "B: `undefined`"
            },
            {
                "key": "C",
                "value": "C: `ReferenceError`"
            },
            {
                "key": "D",
                "value": "D: `TypeError`"
            }
        ]
    },
    {
        "id": 21,
        "title": "21. 输出是什么？",
        "result": "答案: A",
        "code": "const sum = eval('10*10+5')\n",
        "answer": "代码以字符串形式传递进来，`eval` 对其求值。如果它是一个表达式，就像本例中那样，它对表达式求值。表达式是 `10 * 10 + 5`。这将返回数字 `105`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `105`"
            },
            {
                "key": "B",
                "value": "B: `\"105\"`"
            },
            {
                "key": "C",
                "value": "C: `TypeError`"
            },
            {
                "key": "D",
                "value": "D: `\"10*10+5\"`"
            }
        ]
    },
    {
        "id": 22,
        "title": "22. cool_secret 可访问多长时间？",
        "result": "答案: B",
        "code": "sessionStorage.setItem('cool_secret', 123)\n",
        "answer": "关闭 <strong>tab 标签页</strong> 后，`sessionStorage` 存储的数据才会删除。\n如果使用 `localStorage`，那么数据将永远在那里，除非调用了 `localStorage.clear()`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: 永远，数据不会丢失。"
            },
            {
                "key": "B",
                "value": "B: 当用户关掉标签页时。"
            },
            {
                "key": "C",
                "value": "C: 当用户关掉整个浏览器，而不只是关掉标签页。"
            },
            {
                "key": "D",
                "value": "D: 当用户关闭电脑时。"
            }
        ]
    },
    {
        "id": 23,
        "title": "23. 输出是什么？",
        "result": "答案: B",
        "code": "var num = 8\nvar num = 10\n\nconsole.log(num)\n",
        "answer": "使用 `var` 关键字，你可以用相同的名称声明多个变量。然后变量将保存最新的值。\n你不能使用 `let` 或 `const` 来实现这一点，因为它们是块作用域的。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `8`"
            },
            {
                "key": "B",
                "value": "B: `10`"
            },
            {
                "key": "C",
                "value": "C: `SyntaxError`"
            },
            {
                "key": "D",
                "value": "D: `ReferenceError`"
            }
        ]
    },
    {
        "id": 24,
        "title": "24. 输出是什么？",
        "result": "答案: C",
        "code": "const obj = { 1: 'a', 2: 'b', 3: 'c' }\nconst set = new Set([1, 2, 3, 4, 5])\n\nobj.hasOwnProperty('1')\nobj.hasOwnProperty(1)\nset.has('1')\nset.has(1)\n",
        "answer": "所有对象的键（不包括 Symbol）在底层都是字符串，即使你自己没有将其作为字符串输入。这就是为什么 `obj.hasOwnProperty('1')` 也返回 `true`。\n对于集合，它不是这样工作的。在我们的集合中没有 `'1'`：`set.has('1')` 返回 `false`。它有数字类型为 `1`，`set.has(1)` 返回 `true`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `false` `true` `false` `true`"
            },
            {
                "key": "B",
                "value": "B: `false` `true` `true` `true`"
            },
            {
                "key": "C",
                "value": "C: `true` `true` `false` `true`"
            },
            {
                "key": "D",
                "value": "D: `true` `true` `true` `true`"
            }
        ]
    },
    {
        "id": 25,
        "title": "25. 输出是什么？",
        "result": "答案: C",
        "code": "const obj = { a: 'one', b: 'two', a: 'three' }\nconsole.log(obj)\n",
        "answer": "如果你有两个名称相同的键，则键会被替换掉。它仍然位于第一个键出现的位置，但是值是最后出现那个键的值。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `{ a: \"one\", b: \"two\" }`"
            },
            {
                "key": "B",
                "value": "B: `{ b: \"two\", a: \"three\" }`"
            },
            {
                "key": "C",
                "value": "C: `{ a: \"three\", b: \"two\" }`"
            },
            {
                "key": "D",
                "value": "D: `SyntaxError`"
            }
        ]
    },
    {
        "id": 26,
        "title": "26. JavaScript 全局执行上下文为你做了两件事：全局对象和 this 关键字。",
        "result": "答案: A",
        "code": "",
        "answer": "基本执行上下文是全局执行上下文：它是代码中随处可访问的内容。\n",
        "options": [
            {
                "key": "A",
                "value": "A: 对"
            },
            {
                "key": "B",
                "value": "B: 错"
            },
            {
                "key": "C",
                "value": "C: 看情况"
            }
        ]
    },
    {
        "id": 27,
        "title": "27. 输出是什么？",
        "result": "答案: C",
        "code": "for (let i = 1; i < 5; i++) {\n  if (i === 3) continue\n  console.log(i)\n}\n",
        "answer": "如果某个条件返回 `true`，则 `continue` 语句跳过本次迭代。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `1` `2`"
            },
            {
                "key": "B",
                "value": "B: `1` `2` `3`"
            },
            {
                "key": "C",
                "value": "C: `1` `2` `4`"
            },
            {
                "key": "D",
                "value": "D: `1` `3` `4`"
            }
        ]
    },
    {
        "id": 28,
        "title": "28. 输出是什么？",
        "result": "答案: A",
        "code": "String.prototype.giveLydiaPizza = () => {\n  return 'Just give Lydia pizza already!'\n}\n\nconst name = 'Lydia'\n\nname.giveLydiaPizza()\n",
        "answer": "`String` 是内置的构造函数，我们可以向它添加属性。我只是在它的原型中添加了一个方法。基本类型字符串被自动转换为字符串对象，由字符串原型函数生成。因此，所有 string(string 对象) 都可以访问该方法！\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"Just give Lydia pizza already!\"`"
            },
            {
                "key": "B",
                "value": "B: `TypeError: not a function`"
            },
            {
                "key": "C",
                "value": "C: `SyntaxError`"
            },
            {
                "key": "D",
                "value": "D: `undefined`"
            }
        ]
    },
    {
        "id": 29,
        "title": "29. 输出是什么？",
        "result": "答案: B",
        "code": "const a = {}\nconst b = { key: 'b' }\nconst c = { key: 'c' }\n\na[b] = 123\na[c] = 456\n\nconsole.log(a[b])\n",
        "answer": "对象的键被自动转换为字符串。我们试图将一个对象 `b` 设置为对象 `a` 的键，且相应的值为 `123`。\n然而，当字符串化一个对象时，它会变成 `\"[object Object]\"`。因此这里说的是，`a[\"[object Object]\"] = 123`。然后，我们再一次做了同样的事情，`c` 是另外一个对象，这里也有隐式字符串化，于是，`a[\"[object Object]\"] = 456`。\n然后，我们打印 `a[b]`，也就是 `a[\"[object Object]\"]`。之前刚设置为 `456`，因此返回的是 `456`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `123`"
            },
            {
                "key": "B",
                "value": "B: `456`"
            },
            {
                "key": "C",
                "value": "C: `undefined`"
            },
            {
                "key": "D",
                "value": "D: `ReferenceError`"
            }
        ]
    },
    {
        "id": 30,
        "title": "30. 输出是什么？",
        "result": "答案: B",
        "code": "const foo = () => console.log('First')\nconst bar = () => setTimeout(() => console.log('Second'))\nconst baz = () => console.log('Third')\n\nbar()\nfoo()\nbaz()\n",
        "answer": "我们有一个 `setTimeout` 函数，并首先调用它。然而，它是最后打印日志的。\n这是因为在浏览器中，我们不仅有运行时引擎，还有一个叫做 `WebAPI` 的东西。`WebAPI` 提供了 `setTimeout` 函数，也包含其他的，例如 DOM。\n将 **callback** 推送到 WebAPI 后，`setTimeout` 函数本身 (但不是回调！) 将从栈中弹出。\n&lt;img src=\"https://i.imgur.com/X5wsHOg.png\" width=\"200\"&gt;\n现在，`foo` 被调用，打印 `\"First\"`。\n&lt;img src=\"https://i.imgur.com/Pvc0dGq.png\" width=\"200\"&gt;\n`foo` 从栈中弹出，`baz` 被调用。打印 `\"Third\"`。\n&lt;img src=\"https://i.imgur.com/WhA2bCP.png\" width=\"200\"&gt;\nWebAPI 不能随时向栈内添加内容。相反，它将回调函数推到名为 **queue** 的地方。\n&lt;img src=\"https://i.imgur.com/NSnDZmU.png\" width=\"200\"&gt;\n这就是事件循环开始工作的地方。一个<strong>事件循环</strong>查看栈和任务队列。如果栈是空的，它接受队列上的第一个元素并将其推入栈。\n&lt;img src=\"https://i.imgur.com/uyiScAI.png\" width=\"200\"&gt;\n`bar` 被调用，打印 `\"Second\"`，然后它被栈弹出。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `First` `Second` `Third`"
            },
            {
                "key": "B",
                "value": "B: `First` `Third` `Second`"
            },
            {
                "key": "C",
                "value": "C: `Second` `First` `Third`"
            },
            {
                "key": "D",
                "value": "D: `Second` `Third` `First`"
            }
        ]
    },
    {
        "id": 31,
        "title": "31. 当点击按钮时，event.target 是什么？",
        "result": "答案: C",
        "code": "",
        "answer": "导致事件的最深嵌套的元素是事件的 target。你可以通过 `event.stopPropagation` 来停止冒泡。\n",
        "options": [
            {
                "key": "A",
                "value": "A: Outer `div`"
            },
            {
                "key": "B",
                "value": "B: Inner `div`"
            },
            {
                "key": "C",
                "value": "C: `button`"
            },
            {
                "key": "D",
                "value": "D: 一个包含所有嵌套元素的数组。"
            }
        ]
    },
    {
        "id": 32,
        "title": "32. 当您单击该段落时，日志输出是什么？",
        "result": "答案: A",
        "code": "",
        "answer": "如果我们点击 `p`，我们会看到两个日志：`p` 和 `div`。在事件传播期间，有三个阶段：捕获、目标和冒泡。默认情况下，事件处理程序在冒泡阶段执行（除非将 `useCapture` 设置为 `true`）。它从嵌套最深的元素向外传播。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `p` `div`"
            },
            {
                "key": "B",
                "value": "B: `div` `p`"
            },
            {
                "key": "C",
                "value": "C: `p`"
            },
            {
                "key": "D",
                "value": "D: `div`"
            }
        ]
    },
    {
        "id": 33,
        "title": "33. 输出是什么？",
        "result": "答案: D",
        "code": "const person = { name: 'Lydia' }\n\nfunction sayHi(age) {\n  console.log(`${this.name} is ${age}`)\n}\n\nsayHi.call(person, 21)\nsayHi.bind(person, 21)\n",
        "answer": "使用这两种方法，我们都可以传递我们希望 `this` 关键字引用的对象。但是，`.call` 是<strong>立即执行</strong>的。\n`.bind` 返回函数的<strong>副本</strong>，但带有绑定上下文！它不是立即执行的。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `undefined is 21` `Lydia is 21`"
            },
            {
                "key": "B",
                "value": "B: `function` `function`"
            },
            {
                "key": "C",
                "value": "C: `Lydia is 21` `Lydia is 21`"
            },
            {
                "key": "D",
                "value": "D: `Lydia is 21` `function`"
            }
        ]
    },
    {
        "id": 34,
        "title": "34. 输出是什么？",
        "result": "答案: B",
        "code": "function sayHi() {\n  return (() => 0)()\n}\n\ntypeof sayHi()\n",
        "answer": "`sayHi` 方法返回的是立即执行函数 (IIFE) 的返回值。此立即执行函数的返回值是 `0`， 类型是 `number`\n参考：只有 7 种内置类型：`null`，`undefined`，`boolean`，`number`，`string`，`object`, `symbol` 和 `bigint`。 `function` 不是一种类型，函数是对象，它的类型是`object`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"object\"`"
            },
            {
                "key": "B",
                "value": "B: `\"number\"`"
            },
            {
                "key": "C",
                "value": "C: `\"function\"`"
            },
            {
                "key": "D",
                "value": "D: `\"undefined\"`"
            }
        ]
    },
    {
        "id": 35,
        "title": "35. 下面哪些值是 falsy?",
        "result": "答案: A",
        "code": "0\nnew Number(0)\n('')\n(' ')\nnew Boolean(false)\nundefined\n",
        "answer": "只有 8 种 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy\">falsy</a> 值：\n`Function` 构造函数，比如 `new Number` 和 `new Boolean`，是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy\">truthy</a>。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `0`, `''`, `undefined`"
            },
            {
                "key": "B",
                "value": "B: `0`, `new Number(0)`, `''`, `new Boolean(false)`, `undefined`"
            },
            {
                "key": "C",
                "value": "C: `0`, `''`, `new Boolean(false)`, `undefined`"
            },
            {
                "key": "D",
                "value": "D: All of them are falsy"
            },
            {
                "key": "u",
                "value": "`undefined`"
            },
            {
                "key": "n",
                "value": "`null`"
            },
            {
                "key": "N",
                "value": "`NaN`"
            },
            {
                "key": "f",
                "value": "`false`"
            },
            {
                "key": "e",
                "value": "`''` (empty string)"
            },
            {
                "key": "0",
                "value": "`0`"
            },
            {
                "key": "0",
                "value": "`-0`"
            },
            {
                "key": "0",
                "value": "`0n` (BigInt(0))"
            }
        ]
    },
    {
        "id": 36,
        "title": "36. 输出是什么？",
        "result": "答案: B",
        "code": "console.log(typeof typeof 1)\n",
        "answer": "`typeof 1` 返回 `\"number\"`。\n`typeof \"number\"` 返回 `\"string\"`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"number\"`"
            },
            {
                "key": "B",
                "value": "B: `\"string\"`"
            },
            {
                "key": "C",
                "value": "C: `\"object\"`"
            },
            {
                "key": "D",
                "value": "D: `\"undefined\"`"
            }
        ]
    },
    {
        "id": 37,
        "title": "37. 输出是什么？",
        "result": "答案: C",
        "code": "const numbers = [1, 2, 3]\nnumbers[10] = 11\nconsole.log(numbers)\n",
        "answer": "当你为数组设置超过数组长度的值的时候， JavaScript 会创建名为 \"empty slots\" 的东西。它们的值实际上是 `undefined`。你会看到以下场景：\n`[1, 2, 3, 7 x empty, 11]`\n这取决于你的运行环境（每个浏览器，以及 node 环境，都有可能不同）\n",
        "options": [
            {
                "key": "A",
                "value": "A: `[1, 2, 3, 7 x null, 11]`"
            },
            {
                "key": "B",
                "value": "B: `[1, 2, 3, 11]`"
            },
            {
                "key": "C",
                "value": "C: `[1, 2, 3, 7 x empty, 11]`"
            },
            {
                "key": "D",
                "value": "D: `SyntaxError`"
            }
        ]
    },
    {
        "id": 38,
        "title": "38. 输出是什么？",
        "result": "答案: A",
        "code": "(() => {\n  let x, y\n  try {\n    throw new Error()\n  } catch (x) {\n    (x = 1), (y = 2)\n    console.log(x)\n  }\n  console.log(x)\n  console.log(y)\n})()\n",
        "answer": "`catch` 代码块接收参数 `x`。当我们传递参数时，这与之前定义的变量 `x` 不同 。这个 `x` 是属于 `catch` 块级作用域的。\n然后，我们将块级作用域中的变量赋值为 `1`，同时也设置了变量 `y` 的值。现在，我们打印块级作用域中的变量 `x`，值为 `1`。\n`catch` 块之外的变量 `x` 的值仍为 `undefined`， `y` 的值为 `2`。当我们在 `catch` 块之外执行 `console.log(x)` 时，返回 `undefined`，`y` 返回 `2`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `1` `undefined` `2`"
            },
            {
                "key": "B",
                "value": "B: `undefined` `undefined` `undefined`"
            },
            {
                "key": "C",
                "value": "C: `1` `1` `2`"
            },
            {
                "key": "D",
                "value": "D: `1` `undefined` `undefined`"
            }
        ]
    },
    {
        "id": 40,
        "title": "40. 输出是什么？",
        "result": "答案: C",
        "code": "[[0, 1], [2, 3]].reduce(\n  (acc, cur) => {\n    return acc.concat(cur)\n  },\n  [1, 2]\n)\n",
        "answer": "`[1, 2]`是初始值。初始值将会作为首次调用时第一个参数 `acc` 的值。在第一次执行时， `acc` 的值是 `[1, 2]`， `cur` 的值是 `[0, 1]`。合并它们，结果为 `[1, 2, 0, 1]`。\n第二次执行， `acc` 的值是 `[1, 2, 0, 1]`， `cur` 的值是 `[2, 3]`。合并它们，最终结果为 `[1, 2, 0, 1, 2, 3]`\n",
        "options": [
            {
                "key": "A",
                "value": "A: `[0, 1, 2, 3, 1, 2]`"
            },
            {
                "key": "B",
                "value": "B: `[6, 1, 2]`"
            },
            {
                "key": "C",
                "value": "C: `[1, 2, 0, 1, 2, 3]`"
            },
            {
                "key": "D",
                "value": "D: `[1, 2, 6]`"
            }
        ]
    },
    {
        "id": 41,
        "title": "41. 输出是什么？",
        "result": "答案: B",
        "code": "!!null\n!!''\n!!1\n",
        "answer": "`null` 是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy\">falsy</a>。 `!null` 的值是 `true`。 `!true` 的值是 `false`。\n`\"\"` 是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy\">falsy</a>。 `!\"\"` 的值是 `true`。  `!true` 的值是 `false`。\n`1` 是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy\">truthy</a>。 `!1` 的值是 `false`。 `!false` 的值是 `true`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `false` `true` `false`"
            },
            {
                "key": "B",
                "value": "B: `false` `false` `true`"
            },
            {
                "key": "C",
                "value": "C: `false` `true` `true`"
            },
            {
                "key": "D",
                "value": "D: `true` `true` `false`"
            }
        ]
    },
    {
        "id": 42,
        "title": "42. setInterval 方法的返回值是什么？",
        "result": "答案: A",
        "code": "setInterval(() => console.log('Hi'), 1000)\n",
        "answer": "`setInterval` 返回一个唯一的 id。此 id 可被用于 `clearInterval` 函数来取消定时。\n",
        "options": [
            {
                "key": "A",
                "value": "A: 一个唯一的 id"
            },
            {
                "key": "B",
                "value": "B: 该方法指定的毫秒数"
            },
            {
                "key": "C",
                "value": "C: 传递的函数"
            },
            {
                "key": "D",
                "value": "D: `undefined`"
            }
        ]
    },
    {
        "id": 43,
        "title": "43. 输出是什么？",
        "result": "答案: A",
        "code": "[...'Lydia']\n",
        "answer": "string 类型是可迭代的。扩展运算符将迭代的每个字符映射成一个元素。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `[\"L\", \"y\", \"d\", \"i\", \"a\"]`"
            },
            {
                "key": "B",
                "value": "B: `[\"Lydia\"]`"
            },
            {
                "key": "C",
                "value": "C: `[[], \"Lydia\"]`"
            },
            {
                "key": "D",
                "value": "D: `[[\"L\", \"y\", \"d\", \"i\", \"a\"]]`"
            }
        ]
    },
    {
        "id": 44,
        "title": "44. 输出是什么？45. 返回值是什么？",
        "result": "答案: C答案: B",
        "code": "function* generator(i) {\n  yield i;\n  yield i * 2;\n}\n\nconst gen = generator(10);\n\nconsole.log(gen.next().value);\nconsole.log(gen.next().value);\nconst firstPromise = new Promise((res, rej) => {\n  setTimeout(res, 500, \"one\");\n});\n\nconst secondPromise = new Promise((res, rej) => {\n  setTimeout(res, 100, \"two\");\n});\n\nPromise.race([firstPromise, secondPromise]).then(res => console.log(res));\n",
        "answer": "一般的函数在执行之后是不能中途停下的。但是，生成器函数却可以中途 “停下”，之后可以再从停下的地方继续。当生成器遇到`yield`关键字的时候，会生成`yield`后面的值。注意，生成器在这种情况下不 **返回** (**return** ) 值，而是 **生成** (**yield**) 值。\n首先，我们用`10`作为参数`i`来初始化生成器函数。然后使用`next()`方法一步步执行生成器。第一次执行生成器的时候，`i`的值为`10`，遇到第一个`yield`关键字，它要生成`i`的值。此时，生成器 “暂停”，生成了`10`。\n然后，我们再执行`next()`方法。生成器会从刚才暂停的地方继续，这个时候`i`还是`10`。于是我们走到了第二个`yield`关键字处，这时候需要生成的值是`i*2`，`i`为`10`，那么此时生成的值便是`20`。所以这道题的最终结果是`10,20`。\n&lt;/p&gt;\n&lt;/details&gt;\n&lt;details&gt;&lt;summary&gt;&lt;b&gt;答案&lt;/b&gt;&lt;/summary&gt;\n&lt;p&gt;\n当我们向`Promise.race`方法中传入多个`Promise`时，会进行 **优先** 解析。在这个例子中，我们用`setTimeout`给`firstPromise`和`secondPromise`分别设定了 500ms 和 100ms 的定时器。这意味着`secondPromise`会首先解析出字符串`two`。那么此时`res`参数即为`two`，是为输出结果。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `[0, 10], [10, 20]`"
            },
            {
                "key": "B",
                "value": "B: `20, 20`"
            },
            {
                "key": "C",
                "value": "C: `10, 20`"
            },
            {
                "key": "D",
                "value": "D: `0, 10 and 10, 20`"
            },
            {
                "key": "A",
                "value": "A: `\"one\"`"
            },
            {
                "key": "B",
                "value": "B: `\"two\"`"
            },
            {
                "key": "C",
                "value": "C: `\"two\" \"one\"`"
            },
            {
                "key": "D",
                "value": "D: `\"one\" \"two\"`"
            }
        ]
    },
    {
        "id": 45,
        "title": "46. 输出是什么？",
        "result": "答案: D",
        "code": "let person = { name: \"Lydia\" };\nconst members = [person];\nperson = null;\n\nconsole.log(members);\n",
        "answer": "首先我们声明了一个拥有`name`属性的对象 `person`。\n&lt;img src=\"https://i.imgur.com/TML1MbS.png\" width=\"200\"&gt;\n然后我们又声明了一个变量`members`. 将首个元素赋值为变量`person`。 当设置两个对象彼此相等时，它们会通过 **引用** 进行交互。但是当你将引用从一个变量分配至另一个变量时，其实只是执行了一个 **复制** 操作。（注意一点，他们的引用 **并不相同**!）\n&lt;img src=\"https://i.imgur.com/FSG5K3F.png\" width=\"300\"&gt;\n接下来我们让`person`等于`null`。\n&lt;img src=\"https://i.imgur.com/sYjcsMT.png\" width=\"300\"&gt;\n我们没有修改数组第一个元素的值，而只是修改了变量`person`的值，因为元素（复制而来）的引用与`person`不同。`members`的第一个元素仍然保持着对原始对象的引用。当我们输出`members`数组时，第一个元素会将引用的对象打印出来。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `null`"
            },
            {
                "key": "B",
                "value": "B: `[null]`"
            },
            {
                "key": "C",
                "value": "C: `[{}]`"
            },
            {
                "key": "D",
                "value": "D: `[{ name: \"Lydia\" }]`"
            }
        ]
    },
    {
        "id": 46,
        "title": "47. 输出是什么？",
        "result": "答案: B",
        "code": "const person = {\n  name: \"Lydia\",\n  age: 21\n};\n\nfor (const item in person) {\n  console.log(item);\n}\n",
        "answer": "在`for-in`循环中，我们可以通过对象的 key 来进行迭代，也就是这里的`name`和`age`。在底层，对象的 key 都是字符串（如果他们不是 Symbol 的话）。在每次循环中，我们将`item`设定为当前遍历到的 key.所以一开始，`item`是`name`，之后 `item`输出的则是`age`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `{ name: \"Lydia\" }, { age: 21 }`"
            },
            {
                "key": "B",
                "value": "B: `\"name\", \"age\"`"
            },
            {
                "key": "C",
                "value": "C: `\"Lydia\", 21`"
            },
            {
                "key": "D",
                "value": "D: `[\"name\", \"Lydia\"], [\"age\", 21]`"
            }
        ]
    },
    {
        "id": 47,
        "title": "48. 输出是什么？",
        "result": "答案: B",
        "code": "console.log(3 + 4 + \"5\");\n",
        "answer": "当所有运算符的 **优先级** 相同时，计算表达式需要确定运算符的结合顺序，即从右到左还是从左往右。在这个例子中，我们只有一类运算符`+`，对于加法来说，结合顺序就是从左到右。\n`3 + 4`首先计算，得到数字`7`.\n由于类型的强制转换，`7 + '5'`的结果是`\"75\"`. JavaScript 将`7`转换成了字符串，可以参考问题 15.我们可以用`+`号把两个字符串连接起来。 `\"7\" + \"5\"` 就得到了`\"75\"`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"345\"`"
            },
            {
                "key": "B",
                "value": "B: `\"75\"`"
            },
            {
                "key": "C",
                "value": "C: `12`"
            },
            {
                "key": "D",
                "value": "D: `\"12\"`"
            }
        ]
    },
    {
        "id": 48,
        "title": "49. num的值是什么？",
        "result": "答案: C",
        "code": "const num = parseInt(\"7*6\", 10);\n",
        "answer": "只返回了字符串中第一个字母。设定了 **进制** 后 (也就是第二个参数，指定需要解析的数字是什么进制：十进制、十六机制、八进制、二进制等等……),`parseInt` 检查字符串中的字符是否合法。一旦遇到一个在指定进制中不合法的字符后，立即停止解析并且忽略后面所有的字符。\n`*`就是不合法的数字字符。所以只解析到`\"7\"`，并将其解析为十进制的`7`. `num`的值即为`7`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `42`"
            },
            {
                "key": "B",
                "value": "B: `\"42\"`"
            },
            {
                "key": "C",
                "value": "C: `7`"
            },
            {
                "key": "D",
                "value": "D: `NaN`"
            }
        ]
    },
    {
        "id": 49,
        "title": "50. 输出是什么？",
        "result": "答案: C",
        "code": "[1, 2, 3].map(num => {\n  if (typeof num === \"number\") return;\n  return num * 2;\n});\n",
        "answer": "对数组进行映射的时候，`num`就是当前循环到的元素。在这个例子中，所有的映射都是 number 类型，所以 if 中的判断`typeof num === \"number\"`结果都是`true`.map 函数创建了新数组并且将函数的返回值插入数组。\n但是，没有任何值返回。当函数没有返回任何值时，即默认返回`undefined`.对数组中的每一个元素来说，函数块都得到了这个返回值，所以结果中每一个元素都是`undefined`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `[]`"
            },
            {
                "key": "B",
                "value": "B: `[null, null, null]`"
            },
            {
                "key": "C",
                "value": "C: `[undefined, undefined, undefined]`"
            },
            {
                "key": "D",
                "value": "D: `[ 3 x empty ]`"
            }
        ]
    },
    {
        "id": 50,
        "title": "51. 输出的是什么？",
        "result": "答案: A",
        "code": "function getInfo(member, year) {\n  member.name = \"Lydia\";\n  year = \"1998\";\n}\n\nconst person = { name: \"Sarah\" };\nconst birthYear = \"1997\";\n\ngetInfo(person, birthYear);\n\nconsole.log(person, birthYear);\n",
        "answer": "普通参数都是 **值** 传递的，而对象则不同，是 **引用** 传递。所以说，`birthYear`是值传递，因为他是个字符串而不是对象。当我们对参数进行值传递时，会创建一份该值的 **复制** 。（可以参考问题 46）\n变量`birthYear`有一个对`\"1997\"`的引用，而传入的参数也有一个对`\"1997\"`的引用，但二者的引用并不相同。当我们通过给 `year`赋值`\"1998\"`来更新`year`的值的时候我们只是更新了`year`（的引用）。此时`birthYear`仍然是`\"1997\"`.\n而`person`是个对象。参数`member`引用与之 **相同的** 对象。当我们修改`member`所引用对象的属性时，`person`的相应属性也被修改了，因为他们引用了相同的对象。`person`的 `name`属性也变成了 `\"Lydia\"`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `{ name: \"Lydia\" }, \"1997\"`"
            },
            {
                "key": "B",
                "value": "B: `{ name: \"Sarah\" }, \"1998\"`"
            },
            {
                "key": "C",
                "value": "C: `{ name: \"Lydia\" }, \"1998\"`"
            },
            {
                "key": "D",
                "value": "D: `{ name: \"Sarah\" }, \"1997\"`"
            }
        ]
    },
    {
        "id": 51,
        "title": "52. 输出是什么？",
        "result": "答案: D",
        "code": "function greeting() {\n  throw \"Hello world!\";\n}\n\nfunction sayHi() {\n  try {\n    const data = greeting();\n    console.log(\"It worked!\", data);\n  } catch (e) {\n    console.log(\"Oh no an error:\", e);\n  }\n}\n\nsayHi();\n",
        "answer": "通过`throw`语句，我么可以创建自定义错误。 而通过它，我们可以抛出异常。异常可以是一个&lt;b&gt;字符串&lt;/b&gt;，一个 &lt;b&gt;数字&lt;/b&gt;，一个 &lt;b&gt;布尔类型&lt;/b&gt; 或者是一个 &lt;b&gt;对象&lt;/b&gt;。在本例中，我们的异常是字符串`'Hello world'`.\n通过 `catch`语句，我们可以设定当`try`语句块中抛出异常后应该做什么处理。在本例中抛出的异常是字符串`'Hello world'`. `e`就是这个字符串，因此被输出。最终结果就是`'Oh an error: Hello world'`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"It worked! Hello world!\"`"
            },
            {
                "key": "B",
                "value": "B: `\"Oh no an error: undefined`"
            },
            {
                "key": "C",
                "value": "C: `SyntaxError: can only throw Error objects`"
            },
            {
                "key": "D",
                "value": "D: `\"Oh no an error: Hello world!`"
            }
        ]
    },
    {
        "id": 52,
        "title": "53. 输出是什么？",
        "result": "答案: B",
        "code": "function Car() {\n  this.make = \"Lamborghini\";\n  return { make: \"Maserati\" };\n}\n\nconst myCar = new Car();\nconsole.log(myCar.make);\n",
        "answer": "返回属性的时候，属性的值等于 **返回的** 值，而不是构造函数中设定的值。我们返回了字符串 `\"Maserati\"`，所以 `myCar.make`等于`\"Maserati\"`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"Lamborghini\"`"
            },
            {
                "key": "B",
                "value": "B: `\"Maserati\"`"
            },
            {
                "key": "C",
                "value": "C: `ReferenceError`"
            },
            {
                "key": "D",
                "value": "D: `TypeError`"
            }
        ]
    },
    {
        "id": 53,
        "title": "54. 输出是什么？",
        "result": "答案: A",
        "code": "(() => {\n  let x = (y = 10);\n})();\n\nconsole.log(typeof x);\nconsole.log(typeof y);\ny = 10;\nlet x = y;\n",
        "answer": "`let x = y = 10;` 是下面这个表达式的缩写：\n我们设定`y`等于`10`时，我们实际上增加了一个属性`y`给全局对象 (浏览器里的`window`, Nodejs 里的`global`)。在浏览器中， `window.y`等于`10`.\n然后我们声明了变量`x`等于`y`，也是`10`.但变量是使用 `let`声明的，它只作用于 **块级作用域**，仅在声明它的块中有效；就是案例中的立即调用表达式 (IIFE)。使用`typeof`操作符时，操作值 `x`没有被定义：因为我们在`x`声明块的外部，无法调用它。这就意味着`x`未定义。未分配或是未声明的变量类型为`\"undefined\"`. `console.log(typeof x)`返回`\"undefined\"`.\n而我们创建了全局变量`y`，并且设定`y`等于`10`.这个值在我们的代码各处都访问的到。 `y`已经被定义了，而且有一个`\"number\"`类型的值。 `console.log(typeof y)`返回`\"number\"`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"undefined\", \"number\"`"
            },
            {
                "key": "B",
                "value": "B: `\"number\", \"number\"`"
            },
            {
                "key": "C",
                "value": "C: `\"object\", \"number\"`"
            },
            {
                "key": "D",
                "value": "D: `\"number\", \"undefined\"`"
            }
        ]
    },
    {
        "id": 54,
        "title": "<a name=20190629></a>55. 输出是什么？",
        "result": "答案: A",
        "code": "class Dog {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nDog.prototype.bark = function() {\n  console.log(`Woof I am ${this.name}`);\n};\n\nconst pet = new Dog(\"Mara\");\n\npet.bark();\n\ndelete Dog.prototype.bark;\n\npet.bark();\n",
        "answer": "我们可以用`delete`关键字删除对象的属性，对原型也是适用的。删除了原型的属性后，该属性在原型链上就不可用了。在本例中，函数`bark`在执行了`delete Dog.prototype.bark`后不可用，然而后面的代码还在调用它。\n当我们尝试调用一个不存在的函数时`TypeError`异常会被抛出。在本例中就是 `TypeError: pet.bark is not a function`，因为`pet.bark`是`undefined`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"Woof I am Mara\"`, `TypeError`"
            },
            {
                "key": "B",
                "value": "B: `\"Woof I am Mara\"`,`\"Woof I am Mara\"`"
            },
            {
                "key": "C",
                "value": "C: `\"Woof I am Mara\"`, `undefined`"
            },
            {
                "key": "D",
                "value": "D: `TypeError`, `TypeError`"
            }
        ]
    },
    {
        "id": 55,
        "title": "56. 输出是什么？",
        "result": "答案: D",
        "code": "const set = new Set([1, 1, 2, 3, 4]);\n\nconsole.log(set);\n",
        "answer": "`Set`对象是独一无二的值的集合：也就是说同一个值在其中仅出现一次。\n我们传入了数组`[1, 1, 2, 3, 4]`，他有一个重复值`1`.以为一个集合里不能有两个重复的值，其中一个就被移除了。所以结果是 `{1, 2, 3, 4}`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `[1, 1, 2, 3, 4]`"
            },
            {
                "key": "B",
                "value": "B: `[1, 2, 3, 4]`"
            },
            {
                "key": "C",
                "value": "C: `{1, 1, 2, 3, 4}`"
            },
            {
                "key": "D",
                "value": "D: `{1, 2, 3, 4}`"
            }
        ]
    },
    {
        "id": 56,
        "title": "57. 输出是什么？",
        "result": "答案: C",
        "code": "// counter.js\nlet counter = 10;\nexport default counter;\n// index.js\nimport myCounter from \"./counter\";\n\nmyCounter += 1;\n\nconsole.log(myCounter);\n",
        "answer": "引入的模块是 **只读** 的：你不能修改引入的模块。只有导出他们的模块才能修改其值。\n当我们给`myCounter`增加一个值的时候会抛出一个异常： `myCounter`是只读的，不能被修改。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `10`"
            },
            {
                "key": "B",
                "value": "B: `11`"
            },
            {
                "key": "C",
                "value": "C: `Error`"
            },
            {
                "key": "D",
                "value": "D: `NaN`"
            }
        ]
    },
    {
        "id": 57,
        "title": "58. 输出是什么？",
        "result": "答案: A",
        "code": "const name = \"Lydia\";\nage = 21;\n\nconsole.log(delete name);\nconsole.log(delete age);\n",
        "answer": "`delete`操作符返回一个布尔值： `true`指删除成功，否则返回`false`. 但是通过 `var`, `const` 或 `let` 关键字声明的变量无法用 `delete` 操作符来删除。\n`name`变量由`const`关键字声明，所以删除不成功：返回 `false`. 而我们设定`age`等于`21`时，我们实际上添加了一个名为`age`的属性给全局对象。对象中的属性是可以删除的，全局对象也是如此，所以`delete age`返回`true`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `false`, `true`"
            },
            {
                "key": "B",
                "value": "B: `\"Lydia\"`, `21`"
            },
            {
                "key": "C",
                "value": "C: `true`, `true`"
            },
            {
                "key": "D",
                "value": "D: `undefined`, `undefined`"
            }
        ]
    },
    {
        "id": 58,
        "title": "59. 输出是什么？",
        "result": "答案: C",
        "code": "const numbers = [1, 2, 3, 4, 5];\nconst [y] = numbers;\n\nconsole.log(y);\n[a, b] = [1, 2];\n[y] = [1, 2, 3, 4, 5];\n",
        "answer": "我们可以通过解构赋值来解析来自对象的数组或属性的值，比如说：\n&lt;img src=\"https://i.imgur.com/ADFpVop.png\" width=\"200\"&gt;\n`a`的值现在是`1`，`b`的值现在是`2`.而在题目中，我们是这么做的：\n&lt;img src=\"https://i.imgur.com/NzGkMNk.png\" width=\"200\"&gt;\n也就是说，`y`等于数组的第一个值就是数字`1`.我们输出`y`， 返回`1`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `[[1, 2, 3, 4, 5]]`"
            },
            {
                "key": "B",
                "value": "B: `[1, 2, 3, 4, 5]`"
            },
            {
                "key": "C",
                "value": "C: `1`"
            },
            {
                "key": "D",
                "value": "D: `[1]`"
            }
        ]
    },
    {
        "id": 59,
        "title": "60. 输出是什么？",
        "result": "答案: B",
        "code": "const user = { name: \"Lydia\", age: 21 };\nconst admin = { admin: true, ...user };\n\nconsole.log(admin);\n",
        "answer": "扩展运算符`...`为对象的组合提供了可能。你可以复制对象中的键值对，然后把它们加到另一个对象里去。在本例中，我们复制了`user`对象键值对，然后把它们加入到`admin`对象中。`admin`对象就拥有了这些键值对，所以结果为`{ admin: true, name: \"Lydia\", age: 21 }`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `{ admin: true, user: { name: \"Lydia\", age: 21 } }`"
            },
            {
                "key": "B",
                "value": "B: `{ admin: true, name: \"Lydia\", age: 21 }`"
            },
            {
                "key": "C",
                "value": "C: `{ admin: true, user: [\"Lydia\", 21] }`"
            },
            {
                "key": "D",
                "value": "D: `{ admin: true }`"
            }
        ]
    },
    {
        "id": 60,
        "title": "61. 输出是什么？",
        "result": "答案: B",
        "code": "const person = { name: \"Lydia\" };\n\nObject.defineProperty(person, \"age\", { value: 21 });\n\nconsole.log(person);\nconsole.log(Object.keys(person));\n",
        "answer": "通过`defineProperty`方法，我们可以给对象添加一个新属性，或者修改已经存在的属性。而我们使用`defineProperty`方法给对象添加了一个属性之后，属性默认为 **不可枚举 (not enumerable)**. `Object.keys`方法仅返回对象中 **可枚举 (enumerable)** 的属性，因此只剩下了`\"name\"`.\n用`defineProperty`方法添加的属性默认不可变。你可以通过`writable`, `configurable` 和 `enumerable`属性来改变这一行为。这样，`defineProperty`方法可以让您更好地控制要添加到对象的属性。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `{ name: \"Lydia\", age: 21 }`, `[\"name\", \"age\"]`"
            },
            {
                "key": "B",
                "value": "B: `{ name: \"Lydia\", age: 21 }`, `[\"name\"]`"
            },
            {
                "key": "C",
                "value": "C: `{ name: \"Lydia\"}`, `[\"name\", \"age\"]`"
            },
            {
                "key": "D",
                "value": "D: `{ name: \"Lydia\"}`, `[\"age\"]`"
            }
        ]
    },
    {
        "id": 61,
        "title": "62. 输出是什么？",
        "result": "答案: A",
        "code": "const settings = {\n  username: \"lydiahallie\",\n  level: 19,\n  health: 90\n};\n\nconst data = JSON.stringify(settings, [\"level\", \"health\"]);\nconsole.log(data);\n",
        "answer": "`JSON.stringify`的第二个参数是 **替代者 (replacer)**. 替代者 (replacer) 可以是个函数或数组，用以控制哪些值如何被转换为字符串。\n如果替代者 (replacer) 是个 **数组** ，那么就只有包含在数组中的属性将会被转化为字符串。在本例中，只有名为`\"level\"` 和 `\"health\"` 的属性被包括进来， `\"username\"`则被排除在外。 `data` 就等于 `\"{\"level\":19, \"health\":90}\"`.\n而如果替代者 (replacer) 是个 **函数**，这个函数将被对象的每个属性都调用一遍。\n函数返回的值会成为这个属性的值，最终体现在转化后的 JSON 字符串中（译者注：Chrome 下，经过实验，如果所有属性均返回同一个值的时候有异常，会直接将返回值作为结果输出而不会输出 JSON 字符串），而如果返回值为`undefined`，则该属性会被排除在外。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"{\"level\":19, \"health\":90}\"`"
            },
            {
                "key": "B",
                "value": "B: `\"{\"username\": \"lydiahallie\"}\"`"
            },
            {
                "key": "C",
                "value": "C: `\"[\"level\", \"health\"]\"`"
            },
            {
                "key": "D",
                "value": "D: `\"{\"username\": \"lydiahallie\", \"level\":19, \"health\":90}\"`"
            }
        ]
    },
    {
        "id": 62,
        "title": "63. 输出是什么？",
        "result": "答案: A",
        "code": "let num = 10;\n\nconst increaseNumber = () => num++;\nconst increasePassedNumber = number => number++;\n\nconst num1 = increaseNumber();\nconst num2 = increasePassedNumber(num1);\n\nconsole.log(num1);\nconsole.log(num2);\n",
        "answer": "一元操作符 `++` **先返回** 操作值，**再累加** 操作值。`num1`的值是`10`，因为`increaseNumber`函数首先返回`num`的值，也就是`10`，随后再进行 `num`的累加。\n`num2`是`10`因为我们将 `num1`传入`increasePassedNumber`. `number`等于`10`（`num1`的值。同样道理，`++` **先返回** 操作值，**再累加** 操作值。）`number`是`10`，所以`num2`也是`10`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `10`, `10`"
            },
            {
                "key": "B",
                "value": "B: `10`, `11`"
            },
            {
                "key": "C",
                "value": "C: `11`, `11`"
            },
            {
                "key": "D",
                "value": "D: `11`, `12`"
            }
        ]
    },
    {
        "id": 63,
        "title": "64. 输出什么？",
        "result": "答案: C",
        "code": "const value = { number: 10 };\n\nconst multiply = (x = { ...value }) => {\n  console.log(x.number *= 2);\n};\n\nmultiply();\nmultiply();\nmultiply(value);\nmultiply(value);\n",
        "answer": "在 ES6 中，我们可以使用默认值初始化参数。如果没有给函数传参，或者传的参值为 `\"undefined\"` ，那么参数的值将是默认值。上述例子中，我们将 `value` 对象进行了解构并传到一个新对象中，因此 `x` 的默认值为 `{number：10}` 。\n默认参数在调用时才会进行计算，每次调用函数时，都会创建一个新的对象。我们前两次调用 `multiply` 函数且不传递值，那么每一次 `x` 的默认值都为 `{number：10}` ，因此打印出该数字的乘积值为`20`。\n第三次调用 `multiply` 时，我们传递了一个参数，即对象`value`。 `*=`运算符实际上是`x.number = x.number * 2`的简写，我们修改了`x.number`的值，并打印出值`20`。\n第四次，我们再次传递`value`对象。 `x.number`之前被修改为`20`，所以`x.number * = 2`打印为`40`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `20`, `40`, `80`, `160`"
            },
            {
                "key": "B",
                "value": "B: `20`, `40`, `20`, `40`"
            },
            {
                "key": "C",
                "value": "C: `20`, `20`, `20`, `40`"
            },
            {
                "key": "D",
                "value": "D: `NaN`, `NaN`, `20`, `40`"
            }
        ]
    },
    {
        "id": 64,
        "title": "65. 输出什么？",
        "result": "答案: D",
        "code": "[1, 2, 3, 4].reduce((x, y) => console.log(x, y));\n",
        "answer": "`reducer` 函数接收 4 个参数：\n`reducer` 函数的返回值将会分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。\n`reducer` 函数还有一个可选参数`initialValue`，该参数将作为第一次调用回调函数时的第一个参数的值。如果没有提供`initialValue`，则将使用数组中的第一个元素。\n在上述例子，`reduce`方法接收的第一个参数 (Accumulator) 是`x`，第二个参数 (Current Value) 是`y`。\n在第一次调用时，累加器`x`为`1`，当前值`“y”`为`2`，打印出累加器和当前值：`1`和`2`。\n例子中我们的回调函数没有返回任何值，只是打印累加器的值和当前值。如果函数没有返回值，则默认返回`undefined`。 在下一次调用时，累加器为`undefined`，当前值为 “3”，因此`undefined`和`3`被打印出。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `1` `2` and `3` `3` and `6` `4`"
            },
            {
                "key": "B",
                "value": "B: `1` `2` and `2` `3` and `3` `4`"
            },
            {
                "key": "C",
                "value": "C: `1` `undefined` and `2` `undefined` and `3` `undefined` and `4` `undefined`"
            },
            {
                "key": "D",
                "value": "D: `1` `2` and `undefined` `3` and `undefined` `4`"
            }
        ]
    },
    {
        "id": 65,
        "title": "66. 使用哪个构造函数可以成功继承Dog类？",
        "result": "答案: B",
        "code": "class Dog {\n  constructor(name) {\n    this.name = name;\n  }\n};\n\nclass Labrador extends Dog {\n  // 1 \n  constructor(name, size) {\n    this.size = size;\n  }\n  // 2\n  constructor(name, size) {\n    super(name);\n    this.size = size;\n  }\n  // 3\n  constructor(size) {\n    super(name);\n    this.size = size;\n  }\n  // 4 \n  constructor(name, size) {\n    this.name = name;\n    this.size = size;\n  }\n\n};\n",
        "answer": "在子类中，在调用`super`之前不能访问到`this`关键字。 如果这样做，它将抛出一个`ReferenceError`：1 和 4 将引发一个引用错误。\n使用`super`关键字，需要用给定的参数来调用父类的构造函数。 父类的构造函数接收`name`参数，因此我们需要将`name`传递给`super`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: 1"
            },
            {
                "key": "B",
                "value": "B: 2"
            },
            {
                "key": "C",
                "value": "C: 3"
            },
            {
                "key": "D",
                "value": "D: 4"
            }
        ]
    },
    {
        "id": 66,
        "title": "67. 输出什么？",
        "result": "答案: B",
        "code": "// index.js\nconsole.log('running index.js');\nimport { sum } from './sum.js';\nconsole.log(sum(1, 2));\n\n// sum.js\nconsole.log('running sum.js');\nexport const sum = (a, b) => a + b;\n",
        "answer": "`import`命令是编译阶段执行的，在代码运行之前。因此这意味着被导入的模块会先运行，而导入模块的文件会后执行。\n这是 CommonJS 中`require（）`和`import`之间的区别。使用`require()`，您可以在运行代码时根据需要加载依赖项。 如果我们使用`require`而不是`import`，`running index.js`，`running sum.js`，`3`会被依次打印。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `running index.js`, `running sum.js`, `3`"
            },
            {
                "key": "B",
                "value": "B: `running sum.js`, `running index.js`, `3`"
            },
            {
                "key": "C",
                "value": "C: `running sum.js`, `3`, `running index.js`"
            },
            {
                "key": "D",
                "value": "D: `running index.js`, `undefined`, `running sum.js`"
            }
        ]
    },
    {
        "id": 67,
        "title": "68. 输出什么？",
        "result": "答案: A",
        "code": "console.log(Number(2) === Number(2))\nconsole.log(Boolean(false) === Boolean(false))\nconsole.log(Symbol('foo') === Symbol('foo'))\n",
        "answer": "每个`Symbol`都是完全唯一的。传递给`Symbol`的参数只是给`Symbol`的一个描述。 `Symbol`的值不依赖于传递的参数。 当我们测试相等时，我们创建了两个全新的符号：第一个`Symbol（'foo'）`，第二个`Symbol（'foo'）`，这两个值是唯一的，彼此不相等，因此返回`false`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `true`, `true`, `false`"
            },
            {
                "key": "B",
                "value": "B: `false`, `true`, `false`"
            },
            {
                "key": "C",
                "value": "C: `true`, `false`, `true`"
            },
            {
                "key": "D",
                "value": "D: `true`, `true`, `true`"
            }
        ]
    },
    {
        "id": 68,
        "title": "69. 输出什么？",
        "result": "答案: C",
        "code": "const name = \"Lydia Hallie\"\nconsole.log(name.padStart(13))\nconsole.log(name.padStart(2))\n",
        "answer": "使用`padStart`方法，我们可以在字符串的开头添加填充。传递给此方法的参数是字符串的总长度（包含填充）。字符串`Lydia Hallie`的长度为`12`，因此`name.padStart（13）`在字符串的开头只会插入 1（`13 - 12 = 1`）个空格。\n如果传递给`padStart`方法的参数小于字符串的长度，则不会添加填充。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"Lydia Hallie\"`, `\"Lydia Hallie\"`"
            },
            {
                "key": "B",
                "value": "B: `\"           Lydia Hallie\"`, `\"  Lydia Hallie\"` (`\"[13x whitespace]Lydia Hallie\"`, `\"[2x whitespace]Lydia Hallie\"`)"
            },
            {
                "key": "C",
                "value": "C: `\" Lydia Hallie\"`, `\"Lydia Hallie\"` (`\"[1x whitespace]Lydia Hallie\"`, `\"Lydia Hallie\"`)"
            },
            {
                "key": "D",
                "value": "D: `\"Lydia Hallie\"`, `\"Lyd\"`"
            }
        ]
    },
    {
        "id": 69,
        "title": "70. 输出什么？",
        "result": "答案: A",
        "code": "console.log(\"🥑\" + \"💻\");\n",
        "answer": "使用`+`运算符，您可以连接字符串。 上述情况，我们将字符串`“🥑”`与字符串`”💻“`连接起来，产生`”🥑💻“`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"🥑💻\"`"
            },
            {
                "key": "B",
                "value": "B: `257548`"
            },
            {
                "key": "C",
                "value": "C: A string containing their code points"
            },
            {
                "key": "D",
                "value": "D: Error"
            }
        ]
    },
    {
        "id": 70,
        "title": "71. 如何能打印出console.log语句后注释掉的值？",
        "result": "答案: C",
        "code": "function* startGame() {\n  const 答案 = yield \"Do you love JavaScript?\";\n  if (答案 !== \"Yes\") {\n    return \"Oh wow... Guess we're gone here\";\n  }\n  return \"JavaScript loves you back ❤️\";\n}\n\nconst game = startGame();\nconsole.log(/* 1 */); // Do you love JavaScript?\nconsole.log(/* 2 */); // JavaScript loves you back ❤️\n",
        "answer": "`generator`函数在遇到`yield`关键字时会 “暂停” 其执行。 首先，我们需要让函数产生字符串`Do you love JavaScript?`，这可以通过调用`game.next().value`来完成。上述函数的第一行就有一个`yield`关键字，那么运行立即停止了，`yield`表达式本身没有返回值，或者说总是返回`undefined`，这意味着此时变量 `答案` 为`undefined`\n`next`方法可以带一个参数，该参数会被当作上一个 `yield` 表达式的返回值。当我们调用`game.next(\"Yes\").value`时，先前的 `yield` 的返回值将被替换为传递给`next()`函数的参数`\"Yes\"`。此时变量 `答案` 被赋值为 `\"Yes\"`，`if`语句返回`false`，所以`JavaScript loves you back ❤️`被打印。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `game.next(\"Yes\").value` and `game.next().value`"
            },
            {
                "key": "B",
                "value": "B: `game.next.value(\"Yes\")` and `game.next.value()`"
            },
            {
                "key": "C",
                "value": "C: `game.next().value` and `game.next(\"Yes\").value`"
            },
            {
                "key": "D",
                "value": "D: `game.next.value()` and `game.next.value(\"Yes\")`"
            }
        ]
    },
    {
        "id": 71,
        "title": "72. 输出什么？",
        "result": "答案: C",
        "code": "console.log(String.raw`Hello\\nworld`);\nconst path = `C:\\Documents\\Projects\\table.html`\nString.raw`${path}`\nString.raw`C:\\Documents\\Projects\\table.html`\n",
        "answer": "`String.raw`函数是用来获取一个模板字符串的原始字符串的，它返回一个字符串，其中忽略了转义符（`\\n`，`\\v`，`\\t`等）。但反斜杠可能造成问题，因为你可能会遇到下面这种类似情况：\n这将导致：\n`\"C:DocumentsProjects able.html\"`\n直接使用`String.raw`\n它会忽略转义字符并打印：`C:\\Documents\\Projects\\table.html`\n上述情况，字符串是`Hello\\nworld`被打印出。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `Hello world!`"
            },
            {
                "key": "B",
                "value": "B: `Hello` &lt;br /&gt;&nbsp; &nbsp; &nbsp;`world`"
            },
            {
                "key": "C",
                "value": "C: `Hello\\nworld`"
            },
            {
                "key": "D",
                "value": "D: `Hello\\n` &lt;br /&gt; &nbsp; &nbsp; &nbsp;`world`"
            }
        ]
    },
    {
        "id": 72,
        "title": "73. 输出什么？",
        "result": "答案: C",
        "code": "async function getData() {\n  return await Promise.resolve(\"I made it!\");\n}\n\nconst data = getData();\nconsole.log(data);\n",
        "answer": "异步函数始终返回一个 promise。`await`仍然需要等待 promise 的解决：当我们调用`getData()`并将其赋值给`data`，此时`data`为`getData`方法返回的一个挂起的 promise，该 promise 并没有解决。\n如果我们想要访问已解决的值`\"I made it!\"`，可以在`data`上使用`.then()`方法：\n`data.then(res =&gt; console.log(res))`\n这样将打印 `\"I made it!\"`\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"I made it!\"`"
            },
            {
                "key": "B",
                "value": "B: `Promise {&lt;resolved&gt;: \"I made it!\"}`"
            },
            {
                "key": "C",
                "value": "C: `Promise {&lt;pending&gt;}`"
            },
            {
                "key": "D",
                "value": "D: `undefined`"
            }
        ]
    },
    {
        "id": 73,
        "title": "74. 输出什么？",
        "result": "答案: B",
        "code": "function addToList(item, list) {\n  return list.push(item);\n}\n\nconst result = addToList(\"apple\", [\"banana\"]);\nconsole.log(result);\n",
        "answer": "`push()`方法返回新数组的长度。一开始，数组包含一个元素（字符串`\"banana\"`），长度为 1。 在数组中添加字符串`\"apple\"`后，长度变为 2，并将从`addToList`函数返回。\n`push`方法修改原始数组，如果你想从函数返回数组而不是数组长度，那么应该在 push `item`之后返回`list`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `['apple', 'banana']`"
            },
            {
                "key": "B",
                "value": "B: `2`"
            },
            {
                "key": "C",
                "value": "C: `true`"
            },
            {
                "key": "D",
                "value": "D: `undefined`"
            }
        ]
    },
    {
        "id": 74,
        "title": "75. 输出什么？",
        "result": "答案: B",
        "code": "const box = { x: 10, y: 20 };\n\nObject.freeze(box);\n\nconst shape = box;\nshape.x = 100;\nconsole.log(shape)\n",
        "answer": "`Object.freeze`使得无法添加、删除或修改对象的属性（除非属性的值是另一个对象）。\n当我们创建变量`shape`并将其设置为等于冻结对象`box`时，`shape`指向的也是冻结对象。你可以使用`Object.isFrozen`检查一个对象是否被冻结，上述情况，`Object.isFrozen（shape）`将返回`true`。\n由于`shape`被冻结，并且`x`的值不是对象，所以我们不能修改属性`x`。 `x`仍然等于`10`，`{x：10，y：20}`被打印。\n注意，上述例子我们对属性`x`进行修改，可能会导致抛出 TypeError 异常（最常见但不仅限于严格模式下时）。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `{ x: 100, y: 20 }`"
            },
            {
                "key": "B",
                "value": "B: `{ x: 10, y: 20 }`"
            },
            {
                "key": "C",
                "value": "C: `{ x: 100 }`"
            },
            {
                "key": "D",
                "value": "D: `ReferenceError`"
            }
        ]
    },
    {
        "id": 75,
        "title": "76. 输出什么？",
        "result": "答案: D",
        "code": "const { name: myName } = { name: \"Lydia\" };\n\nconsole.log(name);\n",
        "answer": "当我们从右侧的对象解构属性`name`时，我们将其值`Lydia`分配给名为`myName`的变量。\n使用`{name：myName}`，我们是在告诉 JavaScript 我们要创建一个名为`myName`的新变量，并且其值是右侧对象的`name`属性的值。\n当我们尝试打印`name`，一个未定义的变量时，就会引发`ReferenceError`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"Lydia\"`"
            },
            {
                "key": "B",
                "value": "B: `\"myName\"`"
            },
            {
                "key": "C",
                "value": "C: `undefined`"
            },
            {
                "key": "D",
                "value": "D: `ReferenceError`"
            }
        ]
    },
    {
        "id": 76,
        "title": "77. 以下是个纯函数么？",
        "result": "答案: A",
        "code": "function sum(a, b) {\n  return a + b;\n}\n",
        "answer": "纯函数在相同的输入值时，需产生相同的输出，其输出的结果，与输入值以外的其他隐藏信息或状态无关，也和由 I/O 设备产生的外部输出无关。\n纯函数不会产生副作用。\n纯函数与副作用的定义可参考：\nhttps://zh.wikipedia.org/wiki/%E5%89%AF%E4%BD%9C%E7%94%A8_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)\n",
        "options": [
            {
                "key": "A",
                "value": "A: Yes"
            },
            {
                "key": "B",
                "value": "B: No"
            }
        ]
    },
    {
        "id": 77,
        "title": "78. 输出什么？",
        "result": "答案: C",
        "code": "const add = () => {\n  const cache = {};\n  return num => {\n    if (num in cache) {\n      return `From cache! ${cache[num]}`;\n    } else {\n      const result = num + 10;\n      cache[num] = result;\n      return `Calculated! ${result}`;\n    }\n  };\n};\n\nconst addFunction = add();\nconsole.log(addFunction(10));\nconsole.log(addFunction(10));\nconsole.log(addFunction(5 * 2));\n",
        "answer": "`add`函数是一个记忆函数。 通过记忆化，我们可以缓存函数的结果，以加快其执行速度。上述情况，我们创建一个`cache`对象，用于存储先前返回过的值。\n如果我们使用相同的参数多次调用`addFunction`函数，它首先检查缓存中是否已有该值，如果有，则返回缓存值，这将节省执行时间。如果没有，那么它将计算该值，并存储在缓存中。\n我们用相同的值三次调用了`addFunction`函数：\n在第一次调用，`num`等于`10`时函数的值尚未缓存，if 语句`num in cache`返回`false`，else 块的代码被执行：`Calculated! 20`，并且其结果被添加到缓存对象，`cache`现在看起来像`{10：20}`。\n第二次，`cache`对象包含`10`的返回值。 if 语句 `num in cache` 返回`true`，`From cache! 20`被打印。\n第三次，我们将`5 * 2`(值为 10) 传递给函数。 `cache`对象包含`10`的返回值。 if 语句 `num in cache` 返回`true`，`From cache! 20`被打印。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `Calculated! 20` `Calculated! 20` `Calculated! 20`"
            },
            {
                "key": "B",
                "value": "B: `Calculated! 20` `From cache! 20` `Calculated! 20`"
            },
            {
                "key": "C",
                "value": "C: `Calculated! 20` `From cache! 20` `From cache! 20`"
            },
            {
                "key": "D",
                "value": "D: `Calculated! 20` `From cache! 20` `Error`"
            }
        ]
    },
    {
        "id": 78,
        "title": "<a name=20190726></a>79. 输出什么？",
        "result": "答案: A",
        "code": "const myLifeSummedUp = [\"☕\", \"💻\", \"🍷\", \"🍫\"]\n\nfor (let item in myLifeSummedUp) {\n  console.log(item)\n}\n\nfor (let item of myLifeSummedUp) {\n  console.log(item)\n}\n",
        "answer": "通过`for-in`循环，我们可以遍历一个对象<strong>自有的</strong>、<strong>继承的</strong>、<strong>可枚举的</strong>、<strong>非 Symbol 的</strong>属性。 在数组中，可枚举属性是数组元素的 “键”， 即它们的索引。 类似于下面这个对象：\n`{0: \"☕\", 1: \"💻\", 2: \"🍷\", 3: \"🍫\"}`\n其中键则是可枚举属性，因此 `0`，`1`，`2`，`3`被记录。\n通过`for-of`循环，我们可以迭代<strong>可迭代对象</strong>（包括 `Array`，`Map`，`Set`，`String`，`arguments`等）。当我们迭代数组时，在每次迭代中，不同属性的值将被分配给变量`item`，因此`“☕”`，`“💻”`，`“🍷”`，`“🍫”`被打印。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `0` `1` `2` `3` and `\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"`"
            },
            {
                "key": "B",
                "value": "B: `\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"` and `\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"`"
            },
            {
                "key": "C",
                "value": "C: `\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"` and `0` `1` `2` `3`"
            },
            {
                "key": "D",
                "value": "D:  `0` `1` `2` `3` and `{0: \"☕\", 1: \"💻\", 2: \"🍷\", 3: \"🍫\"}`"
            }
        ]
    },
    {
        "id": 79,
        "title": "80. 输出什么？",
        "result": "答案: C",
        "code": "const list = [1 + 2, 1 * 2, 1 / 2]\nconsole.log(list)\n",
        "answer": "数组元素可以包含任何值。 数字，字符串，布尔值，对象，数组，`null`，`undeifned`，以及其他表达式，如日期，函数和计算。\n元素将等于返回的值。 `1 + 2`返回`3`，`1 * 2`返回'2`，'1 / 2`返回`0.5`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `[\"1 + 2\", \"1 * 2\", \"1 / 2\"]`"
            },
            {
                "key": "B",
                "value": "B: `[\"12\", 2, 0.5]`"
            },
            {
                "key": "C",
                "value": "C: `[3, 2, 0.5]`"
            },
            {
                "key": "D",
                "value": "D:  `[1, 1, 1]`"
            }
        ]
    },
    {
        "id": 80,
        "title": "81. 输出什么？",
        "result": "答案: B",
        "code": "function sayHi(name) {\n  return `Hi there, ${name}`\n}\n\nconsole.log(sayHi())\n",
        "answer": "默认情况下，如果不给函数传参，参数的值将为`undefined`。 上述情况，我们没有给参数`name`传值。 `name`等于`undefined`，并被打印。\n在 ES6 中，我们可以使用默认参数覆盖此默认的`undefined`值。 例如：\n`function sayHi（name =“Lydia”）{...}`\n在这种情况下，如果我们没有传递值或者如果我们传递`undefined`，`name`总是等于字符串`Lydia`\n",
        "options": [
            {
                "key": "A",
                "value": "A: `Hi there, `"
            },
            {
                "key": "B",
                "value": "B: `Hi there, undefined`"
            },
            {
                "key": "C",
                "value": "C: `Hi there, null`"
            },
            {
                "key": "D",
                "value": "D:  `ReferenceError`"
            }
        ]
    },
    {
        "id": 81,
        "title": "82. 输出什么？",
        "result": "答案: B",
        "code": "var status = \"😎\"\n\nsetTimeout(() => {\n  const status = \"😍\"\n\n  const data = {\n    status: \"🥑\",\n    getStatus() {\n      return this.status\n    }\n  }\n\n  console.log(data.getStatus())\n  console.log(data.getStatus.call(this))\n}, 0)\n",
        "answer": "`this`关键字的指向取决于使用它的位置。 在<strong>函数</strong>中，比如`getStatus`，`this`指向的是调用它的对象，上述例子中`data`对象调用了`getStatus`，因此`this`指向的就是`data`对象。 当我们打印`this.status`时，`data`对象的`status`属性被打印，即`\"🥑\"`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"🥑\"` and `\"😍\"`"
            },
            {
                "key": "B",
                "value": "B: `\"🥑\"` and `\"😎\"`"
            },
            {
                "key": "C",
                "value": "C: `\"😍\"` and `\"😎\"`"
            },
            {
                "key": "D",
                "value": "D: `\"😎\"` and `\"😎\"`"
            }
        ]
    },
    {
        "id": 82,
        "title": "83. 输出什么？",
        "result": "答案: A",
        "code": "const person = {\n  name: \"Lydia\",\n  age: 21\n}\n\nlet city = person.city\ncity = \"Amsterdam\"\n\nconsole.log(person)\n",
        "answer": "我们将变量`city`设置为等于`person`对象上名为`city`的属性的值。 这个对象上没有名为`city`的属性，因此变量`city`的值为`undefined`。\n请注意，我们没有引用`person`对象本身，只是将变量`city`设置为等于`person`对象上`city`属性的当前值。\n然后，我们将`city`设置为等于字符串`“Amsterdam”`。 这不会更改 person 对象：没有对该对象的引用。\n因此打印`person`对象时，会返回未修改的对象。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `{ name: \"Lydia\", age: 21 }`"
            },
            {
                "key": "B",
                "value": "B: `{ name: \"Lydia\", age: 21, city: \"Amsterdam\" }`"
            },
            {
                "key": "C",
                "value": "C: `{ name: \"Lydia\", age: 21, city: undefined }`"
            },
            {
                "key": "D",
                "value": "D: `\"Amsterdam\"`"
            }
        ]
    },
    {
        "id": 83,
        "title": "84. 输出什么？",
        "result": "答案: C",
        "code": "function checkAge(age) {\n  if (age < 18) {\n    const message = \"Sorry, you're too young.\"\n  } else {\n    const message = \"Yay! You're old enough!\"\n  }\n\n  return message\n}\n\nconsole.log(checkAge(21))\n",
        "answer": "`const`和`let`声明的变量是具有<strong>块级作用域</strong>的，块是大括号（`{}`）之间的任何东西，即上述情况`if / else`语句的花括号。 由于块级作用域，我们无法在声明的块之外引用变量，因此抛出`ReferenceError`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"Sorry, you're too young.\"`"
            },
            {
                "key": "B",
                "value": "B: `\"Yay! You're old enough!\"`"
            },
            {
                "key": "C",
                "value": "C: `ReferenceError`"
            },
            {
                "key": "D",
                "value": "D: `undefined`"
            }
        ]
    },
    {
        "id": 84,
        "title": "85. 什么样的信息将被打印？",
        "result": "答案: C",
        "code": "fetch('https://www.website.com/api/user/1')\n  .then(res => res.json())\n  .then(res => console.log(res))\n",
        "answer": "第二个`.then`中`res`的值等于前一个`.then`中的回调函数返回的值。 你可以像这样继续链接`.then`，将值传递给下一个处理程序。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `fetch`方法的结果"
            },
            {
                "key": "B",
                "value": "B: 第二次调用`fetch`方法的结果"
            },
            {
                "key": "C",
                "value": "C: 前一个`.then()`中回调方法返回的结果"
            },
            {
                "key": "D",
                "value": "D: 总是`undefined`"
            }
        ]
    },
    {
        "id": 85,
        "title": "86. 哪个选项是将hasName设置为true的方法，前提是不能将true作为参数传递？87. 输出什么？",
        "result": "答案: A答案: B",
        "code": "function getName(name) {\n  const hasName = //\n}\nconsole.log(\"I want pizza\"[0])\n",
        "answer": "使用逻辑非运算符`!`，将返回一个布尔值，使用`!! name`，我们可以确定`name`的值是真的还是假的。 如果`name`是真实的，那么`!name`返回`false`。 `!false`返回`true`。\n通过将`hasName`设置为`name`，可以将`hasName`设置为等于传递给`getName`函数的值，而不是布尔值`true`。\n`new Boolean（true）`返回一个对象包装器，而不是布尔值本身。\n`name.length`返回传递的参数的长度，而不是布尔值`true`。\n&lt;/p&gt;\n&lt;/details&gt;\n&lt;details&gt;&lt;summary&gt;&lt;b&gt;答案&lt;/b&gt;&lt;/summary&gt;\n&lt;p&gt;\n可以使用方括号表示法获取字符串中特定索引的字符，字符串中的第一个字符具有索引 0，依此类推。 在这种情况下，我们想要得到索引为 0 的元素，字符`'I'`被记录。\n请注意，IE7 及更低版本不支持此方法。 在这种情况下，应该使用`.charAt（）`\n",
        "options": [
            {
                "key": "A",
                "value": "A: `!!name`"
            },
            {
                "key": "B",
                "value": "B: `name`"
            },
            {
                "key": "C",
                "value": "C: `new Boolean(name)`"
            },
            {
                "key": "D",
                "value": "D: `name.length`"
            },
            {
                "key": "A",
                "value": "A: `\"\"\"`"
            },
            {
                "key": "B",
                "value": "B: `\"I\"`"
            },
            {
                "key": "C",
                "value": "C: `SyntaxError`"
            },
            {
                "key": "D",
                "value": "D: `undefined`"
            }
        ]
    },
    {
        "id": 86,
        "title": "88. 输出什么？",
        "result": "答案: B",
        "code": "function sum(num1, num2 = num1) {\n  console.log(num1 + num2)\n}\n\nsum(10)\n",
        "answer": "您可以将默认参数的值设置为函数的另一个参数，只要另一个参数定义在其之前即可。 我们将值`10`传递给`sum`函数。 如果`sum`函数只接收 1 个参数，则意味着没有传递`num2`的值，这种情况下，`num1`的值等于传递的值`10`。 `num2`的默认值是`num1`的值，即`10`。 `num1 + num2`返回`20`。\n如果您尝试将默认参数的值设置为后面定义的参数，则可能导致参数的值尚未初始化，从而引发错误。比如：\n",
        "options": [
            {
                "key": "A",
                "value": "A: `NaN`"
            },
            {
                "key": "B",
                "value": "B: `20`"
            },
            {
                "key": "C",
                "value": "C: `ReferenceError`"
            },
            {
                "key": "D",
                "value": "D: `undefined`"
            }
        ]
    },
    {
        "id": 87,
        "title": "89. 输出什么？",
        "result": "答案: A",
        "code": "// module.js \nexport default () => \"Hello world\"\nexport const name = \"Lydia\"\n\n// index.js \nimport * as data from \"./module\"\n\nconsole.log(data)\n",
        "answer": "使用`import * as name`语法，我们将`module.js`文件中所有`export`导入到`index.js`文件中，并且创建了一个名为`data`的新对象。 在`module.js`文件中，有两个导出：默认导出和命名导出。 默认导出是一个返回字符串 “Hello World” 的函数，命名导出是一个名为`name`的变量，其值为字符串`“Lydia”`。\n`data`对象具有默认导出的`default`属性，其他属性具有指定 exports 的名称及其对应的值。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `{ default: function default(), name: \"Lydia\" }`"
            },
            {
                "key": "B",
                "value": "B: `{ default: function default() }`"
            },
            {
                "key": "C",
                "value": "C: `{ default: \"Hello world\", name: \"Lydia\" }`"
            },
            {
                "key": "D",
                "value": "D: Global object of `module.js`"
            }
        ]
    },
    {
        "id": 88,
        "title": "90. 输出什么？",
        "result": "答案: C",
        "code": "class Person {\n  constructor(name) {\n    this.name = name\n  }\n}\n\nconst member = new Person(\"John\")\nconsole.log(typeof member)\nfunction Person() {\n  this.name = name\n}\n",
        "answer": "类是构造函数的语法糖，如果用构造函数的方式来重写`Person`类则将是：\n通过`new`来调用构造函数，将会生成构造函数`Person`的实例，对实例执行`typeof`关键字将返回`\"object\"`，上述情况打印出`\"object\"`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"class\"`"
            },
            {
                "key": "B",
                "value": "B: `\"function\"`"
            },
            {
                "key": "C",
                "value": "C: `\"object\"`"
            },
            {
                "key": "D",
                "value": "D: `\"string\"`"
            }
        ]
    },
    {
        "id": 89,
        "title": "91. 输出什么？",
        "result": "答案: D",
        "code": "let newList = [1, 2, 3].push(4)\n\nconsole.log(newList.push(5))\n",
        "answer": "`.push`方法返回数组的长度，而不是数组本身！ 通过将`newList`设置为`[1,2,3].push(4)`，实际上`newList`等于数组的新长度：`4`。\n然后，尝试在`newList`上使用`.push`方法。 由于`newList`是数值`4`，抛出 TypeError。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `[1, 2, 3, 4, 5]`"
            },
            {
                "key": "B",
                "value": "B: `[1, 2, 3, 5]`"
            },
            {
                "key": "C",
                "value": "C: `[1, 2, 3, 4]`"
            },
            {
                "key": "D",
                "value": "D: `Error`"
            }
        ]
    },
    {
        "id": 90,
        "title": "92. 输出什么？",
        "result": "答案: D",
        "code": "function giveLydiaPizza() {\n  return \"Here is pizza!\"\n}\n\nconst giveLydiaChocolate = () => \"Here's chocolate... now go hit the gym already.\"\n\nconsole.log(giveLydiaPizza.prototype)\nconsole.log(giveLydiaChocolate.prototype)\n",
        "answer": "常规函数，例如`giveLydiaPizza`函数，有一个`prototype`属性，它是一个带有`constructor`属性的对象（原型对象）。 然而，箭头函数，例如`giveLydiaChocolate`函数，没有这个`prototype`属性。 尝试使用`giveLydiaChocolate.prototype`访问`prototype`属性时会返回`undefined`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `{ constructor: ...}` `{ constructor: ...}`"
            },
            {
                "key": "B",
                "value": "B: `{}` `{ constructor: ...}`"
            },
            {
                "key": "C",
                "value": "C: `{ constructor: ...}` `{}`"
            },
            {
                "key": "D",
                "value": "D: `{ constructor: ...}` `undefined`"
            }
        ]
    },
    {
        "id": 91,
        "title": "93. 输出什么？",
        "result": "答案: A",
        "code": "const person = {\n  name: \"Lydia\",\n  age: 21\n}\n\nfor (const [x, y] of Object.entries(person)) {\n  console.log(x, y)\n}\n",
        "answer": "`Object.entries()`方法返回一个给定对象自身可枚举属性的键值对数组，上述情况返回一个二维数组，数组每个元素是一个包含键和值的数组：\n`[['name'，'Lydia']，['age'，21]]`\n使用`for-of`循环，我们可以迭代数组中的每个元素，上述情况是子数组。 我们可以使用`const [x，y]`在`for-of`循环中解构子数组。 `x`等于子数组中的第一个元素，`y`等于子数组中的第二个元素。\n第一个子阵列是`[“name”，“Lydia”]`，其中`x`等于`name`，而`y`等于`Lydia`。\n第二个子阵列是`[“age”，21]`，其中`x`等于`age`，而`y`等于`21`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `name` `Lydia` and `age` `21`"
            },
            {
                "key": "B",
                "value": "B: `[\"name\", \"Lydia\"]` and `[\"age\", 21]`"
            },
            {
                "key": "C",
                "value": "C: `[\"name\", \"age\"]` and `undefined`"
            },
            {
                "key": "D",
                "value": "D: `Error`"
            }
        ]
    },
    {
        "id": 92,
        "title": "94. 输出什么？",
        "result": "答案: D",
        "code": "function getItems(fruitList, ...args, favoriteFruit) {\n  return [...fruitList, ...args, favoriteFruit]\n}\n\ngetItems([\"banana\", \"apple\"], \"pear\", \"orange\")\nfunction getItems(fruitList, favoriteFruit, ...args) {\n  return [...fruitList, ...args, favoriteFruit]\n}\n\ngetItems([\"banana\", \"apple\"], \"pear\", \"orange\")\n",
        "answer": "`... args`是剩余参数，剩余参数的值是一个包含所有剩余参数的数组，<strong>并且只能作为最后一个参数</strong>。上述示例中，剩余参数是第二个参数，这是不可能的，并会抛出语法错误。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `[\"banana\", \"apple\", \"pear\", \"orange\"]`"
            },
            {
                "key": "B",
                "value": "B: `[[\"banana\", \"apple\"], \"pear\", \"orange\"]`"
            },
            {
                "key": "C",
                "value": "C: `[\"banana\", \"apple\", [\"pear\"], \"orange\"]`"
            },
            {
                "key": "D",
                "value": "D: `SyntaxError`"
            }
        ]
    },
    {
        "id": 93,
        "title": "<a name=20190817></a>95. 输出什么？",
        "result": "答案: B",
        "code": "function nums(a, b) {\n  if\n  (a > b)\n  console.log('a is bigger')\n  else \n  console.log('b is bigger')\n  return \n  a + b\n}\n\nconsole.log(nums(4, 2))\nconsole.log(nums(1, 2))\n  return;\n  a + b\n",
        "answer": "在 JavaScript 中，我们不必显式地编写分号 (`;`)，但是 JavaScript 引擎仍然在语句之后自动添加分号。这称为<strong>自动分号插入</strong>。例如，一个语句可以是变量，或者像`throw`、`return`、`break`这样的关键字。\n在这里，我们在新的一行上写了一个`return`语句和另一个值`a + b `。然而，由于它是一个新行，引擎并不知道它实际上是我们想要返回的值。相反，它会在`return`后面自动添加分号。你可以这样看：\n这意味着永远不会到达`a + b`，因为函数在`return`关键字之后停止运行。如果没有返回值，就像这里，函数返回`undefined`。注意，在`if/else`语句之后没有自动插入！\n",
        "options": [
            {
                "key": "A",
                "value": "A: `a is bigger`, `6` and `b is bigger`, `3`"
            },
            {
                "key": "B",
                "value": "B: `a is bigger`, `undefined` and `b is bigger`, `undefined`"
            },
            {
                "key": "C",
                "value": "C: `undefined` and `undefined`"
            },
            {
                "key": "D",
                "value": "D: `SyntaxError`"
            }
        ]
    },
    {
        "id": 94,
        "title": "96. 输出什么？",
        "result": "答案: B",
        "code": "class Person {\n  constructor() {\n    this.name = \"Lydia\"\n  }\n}\n\nPerson = class AnotherPerson {\n  constructor() {\n    this.name = \"Sarah\"\n  }\n}\n\nconst member = new Person()\nconsole.log(member.name)\n",
        "answer": "我们可以将类设置为等于其他类/函数构造函数。 在这种情况下，我们将`Person`设置为`AnotherPerson`。 这个构造函数的名字是`Sarah`，所以新的`Person`实例`member`上的 name 属性是`Sarah`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"Lydia\"`"
            },
            {
                "key": "B",
                "value": "B: `\"Sarah\"`"
            },
            {
                "key": "C",
                "value": "C: `Error: cannot redeclare Person`"
            },
            {
                "key": "D",
                "value": "D: `SyntaxError`"
            }
        ]
    },
    {
        "id": 95,
        "title": "97. 输出什么？",
        "result": "答案: D",
        "code": "const info = {\n  [Symbol('a')]: 'b'\n}\n\nconsole.log(info)\nconsole.log(Object.keys(info))\n",
        "answer": "`Symbol`类型是不可枚举的。`Object.keys`方法返回对象上的所有可枚举的键属性。`Symbol`类型是不可见的，并返回一个空数组。 记录整个对象时，所有属性都是可见的，甚至是不可枚举的属性。\n这是`Symbol`的众多特性之一：除了表示完全唯一的值（防止对象意外名称冲突，例如当使用 2 个想要向同一对象添加属性的库时），您还可以`隐藏`这种方式对象的属性（尽管不完全。你仍然可以使用`Object.getOwnPropertySymbols()`方法访问 `Symbol`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `{Symbol('a'): 'b'}` and `[\"{Symbol('a')\"]`"
            },
            {
                "key": "B",
                "value": "B: `{}` and `[]`"
            },
            {
                "key": "C",
                "value": "C: `{ a: \"b\" }` and `[\"a\"]`"
            },
            {
                "key": "D",
                "value": "D: `{Symbol('a'): 'b'}` and `[]`"
            }
        ]
    },
    {
        "id": 96,
        "title": "98. 输出什么？",
        "result": "答案: A",
        "code": "const getList = ([x, ...y]) => [x, y]\nconst getUser = user => { name: user.name, age: user.age }\n\nconst list = [1, 2, 3, 4]\nconst user = { name: \"Lydia\", age: 21 }\n\nconsole.log(getList(list))\nconsole.log(getUser(user))\n",
        "answer": "`getList`函数接收一个数组作为其参数。 在`getList`函数的括号之间，我们立即解构这个数组。 您可以将其视为：\n`[x, ...y] = [1, 2, 3, 4]`\n使用剩余的参数`... y`，我们将所有剩余参数放在一个数组中。 在这种情况下，其余的参数是`2`，`3`和`4`。 `y`的值是一个数组，包含所有其余参数。 在这种情况下，`x`的值等于`1`，所以当我们打印`[x，y]`时，会打印`[1，[2,3,4]]`。\n`getUser`函数接收一个对象。对于箭头函数，如果只返回一个值，我们不必编写花括号。但是，如果您想从一个箭头函数返回一个对象，您必须将它写在圆括号之间，否则两个花括号之间的所有内容都将被解释为一个块语句！在这种情况下，花括号之间的代码不是有效的 JavaScript 代码，因此会抛出 SyntaxError。\n以下函数将返回一个对象：\n`const getUser = user =&gt; ({ name: user.name, age: user.age })`\n",
        "options": [
            {
                "key": "A",
                "value": "A: `[1, [2, 3, 4]]` and `SyntaxError`"
            },
            {
                "key": "B",
                "value": "B: `[1, [2, 3, 4]]` and `{ name: \"Lydia\", age: 21 }`"
            },
            {
                "key": "C",
                "value": "C: `[1, 2, 3, 4]` and `{ name: \"Lydia\", age: 21 }`"
            },
            {
                "key": "D",
                "value": "D: `Error` and `{ name: \"Lydia\", age: 21 }`"
            }
        ]
    },
    {
        "id": 97,
        "title": "99. 输出什么？",
        "result": "答案: C",
        "code": "const name = \"Lydia\"\n\nconsole.log(name())\n",
        "answer": "变量`name`保存字符串的值，该字符串不是函数，因此无法调用。\n当值不是预期类型时，会抛出`TypeErrors`。 JavaScript 期望`name`是一个函数，因为我们试图调用它。 但它是一个字符串，因此抛出`TypeError`：`name is not a function`\n当你编写了一些非有效的 JavaScript 时，会抛出语法错误，例如当你把`return`这个词写成`retrun`时。\n当 JavaScript 无法找到您尝试访问的值的引用时，抛出`ReferenceErrors`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `SyntaxError`"
            },
            {
                "key": "B",
                "value": "B: `ReferenceError`"
            },
            {
                "key": "C",
                "value": "C: `TypeError`"
            },
            {
                "key": "D",
                "value": "D: `undefined`"
            }
        ]
    },
    {
        "id": 98,
        "title": "100. 输出什么？",
        "result": "答案: B",
        "code": "// 🎉✨ This is my 100th question! ✨🎉\n\nconst output = `${[] && 'Im'}possible!\nYou should${'' && `n't`} see a therapist after so much JavaScript lol`\n",
        "answer": "`[]`是一个真值。 使用`&amp;&amp;`运算符，如果左侧值是真值，则返回右侧值。 在这种情况下，左侧值`[]`是一个真值，所以返回`Im`。\n`\"\"`是一个假值。 如果左侧值是假的，则不返回任何内容。 `n't`不会被退回。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `possible! You should see a therapist after so much JavaScript lol`"
            },
            {
                "key": "B",
                "value": "B: `Impossible! You should see a therapist after so much JavaScript lol`"
            },
            {
                "key": "C",
                "value": "C: `possible! You shouldn't see a therapist after so much JavaScript lol`"
            },
            {
                "key": "D",
                "value": "D: `Impossible! You shouldn't see a therapist after so much JavaScript lol`"
            }
        ]
    },
    {
        "id": 99,
        "title": "101.输出什么？",
        "result": "答案: C",
        "code": "const one = (false || {} || null)\nconst two = (null || false || \"\")\nconst three = ([] || 0 || true)\n\nconsole.log(one, two, three)\n",
        "answer": "使用`||`运算符，我们可以返回第一个真值。 如果所有值都是假值，则返回最后一个值。\n`（false || {} || null）`：空对象`{}`是一个真值。 这是第一个（也是唯一的）真值，它将被返回。`one`等于`{}`。\n`（null || false ||“”）`：所有值都是假值。 这意味着返回传递的值`\"\"`。 `two`等于`\"\"`。\n`（[] || 0 ||“”）`：空数组`[]`是一个真值。 这是第一个返回的真值。 `three`等于`[]`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `false` `null` `[]`"
            },
            {
                "key": "B",
                "value": "B: `null` `\"\"` `true`"
            },
            {
                "key": "C",
                "value": "C: `{}` `\"\"` `[]`"
            },
            {
                "key": "D",
                "value": "D: `null` `null` `true`"
            }
        ]
    },
    {
        "id": 100,
        "title": "102. 依次输出什么？",
        "result": "答案: D",
        "code": "const myPromise = () => Promise.resolve('I have resolved!')\n\nfunction firstFunction() {\n  myPromise().then(res => console.log(res))\n  console.log('second')\n}\n\nasync function secondFunction() {\n  console.log(await myPromise())\n  console.log('second')\n}\n\nfirstFunction()\nsecondFunction()\n",
        "answer": "有了 promise，我们通常会说：当我想要调用某个方法，但是由于它可能需要一段时间，因此暂时将它放在一边。只有当某个值被 resolved/rejected，并且执行栈为空时才使用这个值。\n我们可以在`async`函数中通过`.then`和`await`关键字获得该值。 尽管我们可以通过`.then`和`await`获得 promise 的价值，但是它们的工作方式有所不同。\n在 `firstFunction`中，当运行到`myPromise`方法时我们将其放在一边，即 promise 进入微任务队列，其他后面的代码（`console.log('second')`）照常运行，因此`second`被打印出，`firstFunction`方法到此执行完毕，执行栈中宏任务队列被清空，此时开始执行微任务队列中的任务，`I have resolved`被打印出。\n在`secondFunction`方法中，我们通过`await`关键字，暂停了后面代码的执行，直到异步函数的值被解析才开始后面代码的执行。这意味着，它会等着直到 `myPromise` 以值`I have resolved`被解决之后，下一行`second`才开始执行。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `I have resolved!`, `second` and `I have resolved!`, `second`"
            },
            {
                "key": "B",
                "value": "B: `second`, `I have resolved!` and `second`, `I have resolved!`"
            },
            {
                "key": "C",
                "value": "C: `I have resolved!`, `second` and `second`, `I have resolved!`"
            },
            {
                "key": "D",
                "value": "D: `second`, `I have resolved!` and `I have resolved!`, `second`"
            }
        ]
    },
    {
        "id": 101,
        "title": "103. 输出什么？",
        "result": "答案: C",
        "code": "const set = new Set()\n\nset.add(1)\nset.add(\"Lydia\")\nset.add({ name: \"Lydia\" })\n\nfor (let item of set) {\n  console.log(item + 2)\n}\n",
        "answer": "“+” 运算符不仅用于添加数值，还可以使用它来连接字符串。 每当 JavaScript 引擎发现一个或多个值不是数字时，就会将数字强制为字符串。\n第一个是数字 1。 1 + 2 返回数字 3。\n但是，第二个是字符串 “Lydia”。 “Lydia” 是一个字符串，2 是一个数字：2 被强制转换为字符串。 “Lydia” 和 “2” 被连接起来，产生字符串 “Lydia2”。\n`{name：“ Lydia”}`是一个对象。 数字和对象都不是字符串，因此将二者都字符串化。 每当我们对常规对象进行字符串化时，它就会变成`[Object object]`。 与 “2” 串联的 “ [Object object]” 成为 “[Object object]2”。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `3`, `NaN`, `NaN`"
            },
            {
                "key": "B",
                "value": "B: `3`, `7`, `NaN`"
            },
            {
                "key": "C",
                "value": "C: `3`, `Lydia2`, `[Object object]2`"
            },
            {
                "key": "D",
                "value": "D: `\"12\"`, `Lydia2`, `[Object object]2`"
            }
        ]
    },
    {
        "id": 102,
        "title": "104. 结果是什么？105. 输出什么？",
        "result": "答案: C答案: B",
        "code": "Promise.resolve(5)\nfunction compareMembers(person1, person2 = person) {\n  if (person1 !== person2) {\n    console.log(\"Not the same!\")\n  } else {\n    console.log(\"They are the same!\")\n  }\n}\n\nconst person = { name: \"Lydia\" }\n\ncompareMembers(person)\n",
        "answer": "我们可以将我们想要的任何类型的值传递`Promise.resolve`，无论是否`promise`。 该方法本身返回带有已解析值的`Promise` (`&lt;fulfilled&gt;`)。 如果您传递常规函数，它将是具有常规值的已解决`promise`。 如果你通过了 promise，它将是一个已经 resolved 的且带有传的值的 promise。\n上述情况，我们传了数字 5，因此返回一个 resolved 状态的 promise，resolve 值为`5`\n&lt;/p&gt;\n&lt;/details&gt;\n&lt;details&gt;&lt;summary&gt;&lt;b&gt;答案&lt;/b&gt;&lt;/summary&gt;\n&lt;p&gt;\n对象通过引用传递。 当我们检查对象的严格相等性（===）时，我们正在比较它们的引用。\n我们将 “person2” 的默认值设置为 “person” 对象，并将 “person” 对象作为 “person1” 的值传递。\n这意味着两个值都引用内存中的同一位置，因此它们是相等的。\n运行 “ else” 语句中的代码块，并记录`They are the same!` 。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `5`"
            },
            {
                "key": "B",
                "value": "B: `Promise {&lt;pending&gt;: 5}`"
            },
            {
                "key": "C",
                "value": "C: `Promise {&lt;fulfilled&gt;: 5}`"
            },
            {
                "key": "D",
                "value": "D: `Error`"
            },
            {
                "key": "A",
                "value": "A: `Not the same!`"
            },
            {
                "key": "B",
                "value": "B: `They are the same!`"
            },
            {
                "key": "C",
                "value": "C: `ReferenceError`"
            },
            {
                "key": "D",
                "value": "D: `SyntaxError`"
            }
        ]
    },
    {
        "id": 103,
        "title": "106. 输出什么？",
        "result": "答案: D",
        "code": "const colorConfig = {\n  red: true,\n  blue: false,\n  green: true,\n  black: true,\n  yellow: false,\n}\n\nconst colors = [\"pink\", \"red\", \"blue\"]\n\nconsole.log(colorConfig.colors[1])\n",
        "answer": "在 JavaScript 中，我们有两种访问对象属性的方法：括号表示法或点表示法。 在此示例中，我们使用点表示法（`colorConfig.colors`）代替括号表示法（`colorConfig [“ colors”]`）。\n使用点表示法，JavaScript 会尝试使用该确切名称在对象上查找属性。 在此示例中，JavaScript 尝试在 colorconfig 对象上找到名为 colors 的属性。 没有名为 “colors” 的属性，因此返回 “undefined”。\n然后，我们尝试使用`[1]`访问第一个元素的值。 我们无法对未定义的值执行此操作，因此会抛出`Cannot read property '1' of undefined`。\nJavaScript 解释（或取消装箱）语句。 当我们使用方括号表示法时，它会看到第一个左方括号`[`并一直进行下去，直到找到右方括号`]`。 只有这样，它才会评估该语句。 如果我们使用了 colorConfig [colors [1]]，它将返回 colorConfig 对象上 red 属性的值。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `true`"
            },
            {
                "key": "B",
                "value": "B: `false`"
            },
            {
                "key": "C",
                "value": "C: `undefined`"
            },
            {
                "key": "D",
                "value": "D: `TypeError`"
            }
        ]
    },
    {
        "id": 104,
        "title": "107. 输出什么？",
        "result": "答案: A",
        "code": "console.log('❤️' === '❤️')\n",
        "answer": "在内部，表情符号是 unicode。 heat 表情符号的 unicode 是`“ U + 2764 U + FE0F”`。 对于相同的表情符号，它们总是相同的，因此我们将两个相等的字符串相互比较，这将返回 true。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `true`"
            },
            {
                "key": "B",
                "value": "B: `false`"
            }
        ]
    },
    {
        "id": 105,
        "title": "108. 哪些方法修改了原数组？",
        "result": "答案: D",
        "code": "const emojis = ['✨', '🥑', '😍']\n\nemojis.map(x => x + '✨')\nemojis.filter(x => x !== '🥑')\nemojis.find(x => x !== '🥑')\nemojis.reduce((acc, cur) => acc + '✨')\nemojis.slice(1, 2, '✨') \nemojis.splice(1, 2, '✨')\n",
        "answer": "使用`splice`方法，我们通过删除，替换或添加元素来修改原始数组。 在这种情况下，我们从索引 1 中删除了 2 个元素（我们删除了`'🥑'`和`'😍'`），同时添加了✨emoji 表情。\n`map`，`filter`和`slice`返回一个新数组，`find`返回一个元素，而`reduce`返回一个减小的值。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `All of them`"
            },
            {
                "key": "B",
                "value": "B: `map` `reduce` `slice` `splice`"
            },
            {
                "key": "C",
                "value": "C: `map` `slice` `splice`"
            },
            {
                "key": "D",
                "value": "D: `splice`"
            }
        ]
    },
    {
        "id": 106,
        "title": "<a name=20191009></a>109. 输出什么？",
        "result": "答案: A",
        "code": "const food = ['🍕', '🍫', '🥑', '🍔']\nconst info = { favoriteFood: food[0] }\n\ninfo.favoriteFood = '🍝'\n\nconsole.log(food)\n",
        "answer": "我们将`info`对象上的`favoriteFood`属性的值设置为披萨表情符号 “🍕” 的字符串。字符串是原始数据类型。在 JavaScript 中，原始数据类型通过值起作用\n在这种情况下，我们将`info`对象上的`favoriteFood`属性的值设置为等于`food`数组中的第一个元素的值，字符串为披萨表情符号（`'🍕'` ）。字符串是原始数据类型，并且通过值进行交互，我们更改`info`对象上`favoriteFood`属性的值。 food 数组没有改变，因为 favoriteFood 的值只是该数组中第一个元素的值的复制，并且与该元素上的元素没有相同的内存引用食物`[0]`。当我们记录食物时，它仍然是原始数组`['🍕'，'🍫'，'🥑'，'🍔']`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `['🍕', '🍫', '🥑', '🍔']`"
            },
            {
                "key": "B",
                "value": "B: `['🍝', '🍫', '🥑', '🍔']`"
            },
            {
                "key": "C",
                "value": "C: `['🍝', '🍕', '🍫', '🥑', '🍔']`"
            },
            {
                "key": "D",
                "value": "D: `ReferenceError`"
            }
        ]
    },
    {
        "id": 107,
        "title": "110. 这个函数干了什么？",
        "result": "答案: A",
        "code": "JSON.parse()\n// 将数字字符串化为有效的 JSON，然后将 JSON 字符串解析为 JavaScript 值：\nconst jsonNumber = JSON.stringify(4) // '4'\nJSON.parse(jsonNumber) // 4\n\n// 将数组值字符串化为有效的 JSON，然后将 JSON 字符串解析为 JavaScript 值：\nconst jsonArray = JSON.stringify([1, 2, 3]) // '[1, 2, 3]'\nJSON.parse(jsonArray) // [1, 2, 3]\n\n// 将对象字符串化为有效的 JSON，然后将 JSON 字符串解析为 JavaScript 值：\nconst jsonArray = JSON.stringify({ name: \"Lydia\" }) // '{\"name\":\"Lydia\"}'\nJSON.parse(jsonArray) // { name: 'Lydia' }\n",
        "answer": "使用`JSON.parse()`方法，我们可以将 JSON 字符串解析为 JavaScript 值。\n",
        "options": [
            {
                "key": "A",
                "value": "A: Parses JSON to a JavaScript value"
            },
            {
                "key": "B",
                "value": "B: Parses a JavaScript object to JSON"
            },
            {
                "key": "C",
                "value": "C: Parses any JavaScript value to JSON"
            },
            {
                "key": "D",
                "value": "D: Parses JSON to a JavaScript object only"
            }
        ]
    },
    {
        "id": 108,
        "title": "111. 输出什么？",
        "result": "答案: D",
        "code": "let name = 'Lydia'\n\nfunction getName() {\n  console.log(name)\n  let name = 'Sarah'\n}\n\ngetName()\nlet name = 'Lydia'\n\nfunction getName() {\n  console.log(name)\n}\n\ngetName() // Lydia\n",
        "answer": "每个函数都有其自己的执行上下文。 `getName`函数首先在其自身的上下文（范围）内查找，以查看其是否包含我们尝试访问的变量`name`。 上述情况，`getName`函数包含其自己的`name`变量：我们用`let`关键字和`Sarah`的值声明变量`name`。\n带有`let`关键字（和`const`）的变量被提升，但是与`var`不同，它不会被*** 初始化***。 在我们声明（初始化）它们之前，无法访问它们。 这称为 “暂时性死区”。 当我们尝试在声明变量之前访问变量时，JavaScript 会抛出`ReferenceError: Cannot access 'name' before initialization`。\n如果我们不在`getName`函数中声明`name`变量，则 javascript 引擎会查看原型链。会找到其外部作用域有一个名为`name`的变量，其值为`Lydia`。 在这种情况下，它将打印`Lydia`：\n",
        "options": [
            {
                "key": "A",
                "value": "A: Lydia"
            },
            {
                "key": "B",
                "value": "B: Sarah"
            },
            {
                "key": "C",
                "value": "C: `undefined`"
            },
            {
                "key": "D",
                "value": "D: `ReferenceError`"
            }
        ]
    },
    {
        "id": 109,
        "title": "112. 输出什么？",
        "result": "答案: C",
        "code": "function* generatorOne() {\n  yield ['a', 'b', 'c'];\n}\n\nfunction* generatorTwo() {\n  yield* ['a', 'b', 'c'];\n}\n\nconst one = generatorOne()\nconst two = generatorTwo()\n\nconsole.log(one.next().value)\nconsole.log(two.next().value)\nconsole.log(one.next().value) // ['a', 'b', 'c']\nconsole.log(one.next().value) // undefined\nconsole.log(two.next().value) // 'a'\nconsole.log(two.next().value) // 'b'\nconsole.log(two.next().value) // 'c'\nconsole.log(two.next().value) // undefined\n",
        "answer": "通过 `yield` 关键字，我们在 `Generator` 函数里执行`yield`表达式。通过 `yield*` 关键字，我们可以在一个`Generator` 函数里面执行（`yield`表达式）另一个 `Generator` 函数，或可遍历的对象 (如数组).\n在函数 `generatorOne` 中，我们通过 `yield` 关键字 yield 了一个完整的数组 `['a', 'b', 'c']`。函数`one`通过`next`方法返回的对象的`value` 属性的值 (`one.next().value`) 等价于数组 `['a', 'b', 'c']`.\n在函数 `generatorTwo` 中，我们使用 `yield*` 关键字。就相当于函数`two`第一个`yield`的值，等价于在迭代器中第一个 `yield` 的值。数组`['a', 'b', 'c']`就是这个迭代器。第一个 `yield` 的值就是 `a`，所以我们第一次调用 `two.next().value`时，就返回`a`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `a` and `a`"
            },
            {
                "key": "B",
                "value": "B: `a` and `undefined`"
            },
            {
                "key": "C",
                "value": "C: `['a', 'b', 'c']` and `a`"
            },
            {
                "key": "D",
                "value": "D: `a` and `['a', 'b', 'c']`"
            }
        ]
    },
    {
        "id": 110,
        "title": "113. 输出什么？",
        "result": "答案: A",
        "code": "console.log(`${(x => x)('I love')} to program`)\n",
        "answer": "带有模板字面量的表达式首先被执行。相当于字符串会包含表达式，这个立即执行函数 `(x =&gt; x)('I love')` 返回的值。我们向箭头函数 `x =&gt; x` 传递 `'I love'` 作为参数。`x` 等价于返回的 `'I love'`。这就是结果 `I love to program`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `I love to program`"
            },
            {
                "key": "B",
                "value": "B: `undefined to program`"
            },
            {
                "key": "C",
                "value": "C: `${(x =&gt; x)('I love') to program`"
            },
            {
                "key": "D",
                "value": "D: `TypeError`"
            }
        ]
    },
    {
        "id": 111,
        "title": "114. 将会发生什么？",
        "result": "答案: C",
        "code": "let config = {\n  alert: setInterval(() => {\n    console.log('Alert!')\n  }, 1000)\n}\n\nconfig = null\n",
        "answer": "一般情况下当我们将对象赋值为 `null`，那些对象会被进行 **垃圾回收（garbage collected）** 因为已经没有对这些对象的引用了。然而，`setInterval`的参数是一个箭头函数（所以上下文绑定到对象 `config` 了），回调函数仍然保留着对 `config`的引用。只要存在引用，对象就不会被垃圾回收。因为没有被垃圾回收，`setInterval` 的回调每 1000ms (1s) 会被调用一次。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `setInterval` 的回调不会被调用"
            },
            {
                "key": "B",
                "value": "B: `setInterval` 的回调被调用一次"
            },
            {
                "key": "C",
                "value": "C: `setInterval` 的回调仍然会被每秒钟调用"
            },
            {
                "key": "D",
                "value": "D: 我们从没调用过 `config.alert()`, config 为 `null`"
            }
        ]
    },
    {
        "id": 112,
        "title": "115. 哪一个方法会返回 'Hello world!' ？",
        "result": "答案: B",
        "code": "const myMap = new Map()\nconst myFunc = () => 'greeting'\n\nmyMap.set(myFunc, 'Hello world!')\n\n//1\nmyMap.get('greeting')\n//2\nmyMap.get(myFunc)\n//3\nmyMap.get(() => 'greeting')\n",
        "answer": "当通过 `set` 方法添加一个键值对，一个传递给 `set`方法的参数将会是键名，第二个参数将会是值。在这个 case 里，键名为 **函数** `() =&gt; 'greeting'`，值为`'Hello world'`。 `myMap` 现在就是 `{ () =&gt; 'greeting' =&gt; 'Hello world!' }`。\n1 是错的，因为键名不是 `'greeting'` 而是 `() =&gt; 'greeting'`。\n3 是错的，因为我们给`get` 方法传递了一个新的函数。对象受 **引用** 影响。函数也是对象，因此两个函数严格上并不等价，尽管他们相同：他们有两个不同的内存引用地址。\n",
        "options": [
            {
                "key": "A",
                "value": "A: 1"
            },
            {
                "key": "B",
                "value": "B: 2"
            },
            {
                "key": "C",
                "value": "C: 2 and 3"
            },
            {
                "key": "D",
                "value": "D: All of them"
            }
        ]
    },
    {
        "id": 113,
        "title": "116. 输出什么？",
        "result": "答案: C",
        "code": "const person = {\n  name: \"Lydia\",\n  age: 21\n}\n\nconst changeAge = (x = { ...person }) => x.age += 1\nconst changeAgeAndName = (x = { ...person }) => {\n  x.age += 1\n  x.name = \"Sarah\"\n}\n\nchangeAge(person)\nchangeAgeAndName()\n\nconsole.log(person)\n",
        "answer": "函数 `changeAge` 和函数 `changeAgeAndName` 有着不同的参数，定义一个 **新** 生成的对象 `{ ...person }`。这个对象有着所有 `person` 对象 中 k/v 值的副本。\n首项，我们调用 `changeAge` 函数并传递 `person` 对象作为它的参数。这个函数对 `age` 属性进行加一操作。`person` 现在是 `{ name: \"Lydia\", age: 22 }`。\n然后，我们调用函数 `changeAgeAndName` ，然而我们没有传递参数。取而代之，`x` 的值等价 **new** 生成的对象：`{ ...person }`。因为它是一个新生成的对象，它并不会对对象 `person` 造成任何副作用。`person` 仍然等价于 `{ name: \"Lydia\", age: 22 }`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `{name: \"Sarah\", age: 22}`"
            },
            {
                "key": "B",
                "value": "B: `{name: \"Sarah\", age: 23}`"
            },
            {
                "key": "C",
                "value": "C: `{name: \"Lydia\", age: 22}`"
            },
            {
                "key": "D",
                "value": "D: `{name: \"Lydia\", age: 23}`"
            }
        ]
    },
    {
        "id": 114,
        "title": "117. 下面那个选项将会返回 6?",
        "result": "答案: C",
        "code": "function sumValues(x, y, z) {\n\treturn x + y + z;\n}\n",
        "answer": "通过展开操作符 `...`，我们可以 **暂开** 单个可迭代的元素。函数 `sumValues` function 接收三个参数： `x`, `y` 和 `z`。`...[1, 2, 3]` 的执行结果为 `1, 2, 3`，将会传递给函数 `sumValues`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `sumValues([...1, 2, 3])`"
            },
            {
                "key": "B",
                "value": "B: `sumValues([...[1, 2, 3]])`"
            },
            {
                "key": "C",
                "value": "C: `sumValues(...[1, 2, 3])`"
            },
            {
                "key": "D",
                "value": "D: `sumValues([1, 2, 3])`"
            }
        ]
    },
    {
        "id": 115,
        "title": "118. 输出什么？",
        "result": "答案: B",
        "code": "let num = 1;\nconst list = [\"🥳\", \"🤠\", \"🥰\", \"🤪\"];\n\nconsole.log(list[(num += 1)]);\n",
        "answer": "通过 `+=` 操作符，我们对值 `num` 进行加 `1` 操作。 `num` 有初始值 `1`，因此 `1 + 1` 的执行结果为 `2`。数组 `list` 的第二项为 🥰，`console.log(list[2])` 输出 🥰.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `🤠`"
            },
            {
                "key": "B",
                "value": "B: `🥰`"
            },
            {
                "key": "C",
                "value": "C: `SyntaxError`"
            },
            {
                "key": "D",
                "value": "D: `ReferenceError`"
            }
        ]
    },
    {
        "id": 116,
        "title": "119. 输出什么？",
        "result": "答案: B",
        "code": "const person = {\n\tfirstName: \"Lydia\",\n\tlastName: \"Hallie\",\n\tpet: {\n\t\tname: \"Mara\",\n\t\tbreed: \"Dutch Tulip Hound\"\n\t},\n\tgetFullName() {\n\t\treturn `${this.firstName} ${this.lastName}`;\n\t}\n};\n\nconsole.log(person.pet?.name);\nconsole.log(person.pet?.family?.name);\nconsole.log(person.getFullName?.());\nconsole.log(member.getLastName?.());\n",
        "answer": "通过 ES10 或 TS3.7+<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/%E5%8F%AF%E9%80%89%E9%93%BE\">可选链操作符 `?.`</a>，我们不再需要显式检测更深层的嵌套值是否有效。如果我们尝试获取 `undefined` 或 `null` 的值 (**nullish**)，表达将会短路并返回 `undefined`.\n`person.pet?.name`： `person` 有一个名为 `pet` 的属性： `person.pet` 不是 nullish。它有个名为 `name` 的属性，并返回字符串 `Mara`。\n`person.pet?.family?.name`： `person` 有一个名为 `pet` 的属性： `person.pet` 不是 nullish. `pet` **并没有** 一个名为 `family` 的属性，`person.pet.family` 是 nullish。表达式返回 `undefined`。\n`person.getFullName?.()`： `person` 有一个名为 `getFullName` 的属性： `person.getFullName()` 不是 nullish 并可以被调用，返回字符串 `Lydia Hallie`。\n`member.getLastName?.()`: 变量`member` 不存在，因此会抛出错误`ReferenceError`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `undefined` `undefined` `undefined` `undefined`"
            },
            {
                "key": "B",
                "value": "B: `Mara` `undefined` `Lydia Hallie` `ReferenceError`"
            },
            {
                "key": "C",
                "value": "C: `Mara` `null` `Lydia Hallie` `null`"
            },
            {
                "key": "D",
                "value": "D: `null` `ReferenceError` `null` `ReferenceError`"
            }
        ]
    },
    {
        "id": 117,
        "title": "120. 输出什么？",
        "result": "答案: B",
        "code": "const groceries = [\"banana\", \"apple\", \"peanuts\"];\n\nif (groceries.indexOf(\"banana\")) {\n\tconsole.log(\"We have to buy bananas!\");\n} else {\n\tconsole.log(`We don't have to buy bananas!`);\n}\n",
        "answer": "我们传递了一个状态 `groceries.indexOf(\"banana\")` 给 if 条件语句。`groceries.indexOf(\"banana\")` 返回 `0`， 一个 falsy 的值。因为 if 条件语句的状态为 falsy，`else` 块区内的代码执行，并且 `We don't have to buy bananas!` 被输出。\n",
        "options": [
            {
                "key": "A",
                "value": "A: We have to buy bananas!"
            },
            {
                "key": "B",
                "value": "B: We don't have to buy bananas"
            },
            {
                "key": "C",
                "value": "C: `undefined`"
            },
            {
                "key": "D",
                "value": "D: `1`"
            }
        ]
    },
    {
        "id": 118,
        "title": "121. 输出什么？",
        "result": "答案: D",
        "code": "const config = {\n\tlanguages: [],\n\tset language(lang) {\n\t\treturn this.languages.push(lang);\n\t}\n};\n\nconsole.log(config.language);\n",
        "answer": "方法 `language` 是一个 `setter`。Setters 并不保存一个实际值，它们的使命在于 **修改** 属性。当调用方法 `setter`， 返回 `undefined`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `function language(lang) { this.languages.push(lang }`"
            },
            {
                "key": "B",
                "value": "B: `0`"
            },
            {
                "key": "C",
                "value": "C: `[]`"
            },
            {
                "key": "D",
                "value": "D: `undefined`"
            }
        ]
    },
    {
        "id": 119,
        "title": "122. 输出什么？",
        "result": "答案: C",
        "code": "const name = \"Lydia Hallie\";\n\nconsole.log(!typeof name === \"object\");\nconsole.log(!typeof name === \"string\");\n",
        "answer": "`typeof name` 返回 `\"string\"`。字符串 `\"string\"` 是一个 truthy 的值，因此 `!typeof name` 返回一个布尔值 `false`。 `false === \"object\"` 和 `false === \"string\"` 都返回 `false`。\n（如果我们想检测一个值的类型，我们应该用 `!==` 而不是 `!typeof`）\n",
        "options": [
            {
                "key": "A",
                "value": "A: `false` `true`"
            },
            {
                "key": "B",
                "value": "B: `true` `false`"
            },
            {
                "key": "C",
                "value": "C: `false` `false`"
            },
            {
                "key": "D",
                "value": "D: `true` `true`"
            }
        ]
    },
    {
        "id": 120,
        "title": "123. 输出什么？",
        "result": "答案: A",
        "code": "const add = x => y => z => {\n\tconsole.log(x, y, z);\n\treturn x + y + z;\n};\n\nadd(4)(5)(6);\n",
        "answer": "函数 `add` 是一个返回 返回箭头函数的箭头函数 的箭头函数（still with me?）。第一个函数接收一个值为 `4` 的参数 `x`。我们调用第二个函数，它接收一个值为 `5` 的参数 `y`。然后我们调用第三个函数，它接收一个值为 `6` 的参数 `z`。当我们尝试在最后一个箭头函数中获取 `x`, `y` 和 `z` 的值，JS 引擎根据作用域链去找 `x` 和 `y` 的值。得到 `4` `5` `6`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `4` `5` `6`"
            },
            {
                "key": "B",
                "value": "B: `6` `5` `4`"
            },
            {
                "key": "C",
                "value": "C: `4` `function` `function`"
            },
            {
                "key": "D",
                "value": "D: `undefined` `undefined` `6`"
            }
        ]
    },
    {
        "id": 121,
        "title": "124. 输出什么？",
        "result": "答案: C",
        "code": "async function* range(start, end) {\n\tfor (let i = start; i <= end; i++) {\n\t\tyield Promise.resolve(i);\n\t}\n}\n\n(async () => {\n\tconst gen = range(1, 3);\n\tfor await (const item of gen) {\n\t\tconsole.log(item);\n\t}\n})();\n",
        "answer": "我们给 函数 range 传递： `Promise{1}`, `Promise{2}`, `Promise{3}`，Generator 函数 `range` 返回一个全是 async object promise 数组。我们将 async object 赋值给变量 `gen`，之后我们使用`for await ... of` 进行循环遍历。我们将返回的 Promise 实例赋值给 `item`： 第一个返回 `Promise{1}`， 第二个返回 `Promise{2}`，之后是 `Promise{3}`。因为我们正 **awaiting** `item` 的值，resolved 状态的 promsie，promise 数组的 resolved **值** 以此为： `1`，`2`，`3`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `Promise {1}` `Promise {2}` `Promise {3}`"
            },
            {
                "key": "B",
                "value": "B: `Promise {&lt;pending&gt;}` `Promise {&lt;pending&gt;}` `Promise {&lt;pending&gt;}`"
            },
            {
                "key": "C",
                "value": "C: `1` `2` `3`"
            },
            {
                "key": "D",
                "value": "D: `undefined` `undefined` `undefined`"
            }
        ]
    },
    {
        "id": 122,
        "title": "125. 输出什么？",
        "result": "答案: D",
        "code": "const myFunc = ({ x, y, z }) => {\n\tconsole.log(x, y, z);\n};\n\nmyFunc(1, 2, 3);\n",
        "answer": "`myFunc` 期望接收一个包含 `x`, `y` 和 `z` 属性的对象作为它的参数。因为我们仅仅传递三个单独的数字值 (1, 2, 3) 而不是一个含有 `x`, `y` 和 `z` 属性的对象 ({x: 1, y: 2, z: 3})， `x`, `y` 和 `z` 有着各自的默认值 `undefined`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `1` `2` `3`"
            },
            {
                "key": "B",
                "value": "B: `{1: 1}` `{2: 2}` `{3: 3}`"
            },
            {
                "key": "C",
                "value": "C: `{ 1: undefined }` `undefined` `undefined`"
            },
            {
                "key": "D",
                "value": "D: `undefined` `undefined` `undefined`"
            }
        ]
    },
    {
        "id": 123,
        "title": "126. 输出什么？",
        "result": "答案: B",
        "code": "function getFine(speed, amount) {\n  const formattedSpeed = new Intl.NumberFormat(\n    'en-US',\n    { style: 'unit', unit: 'mile-per-hour' }\n  ).format(speed)\n\n  const formattedAmount = new Intl.NumberFormat(\n    'en-US',\n    { style: 'currency', currency: 'USD' }\n  ).format(amount)\n\n  return `The driver drove ${formattedSpeed} and has to pay ${formattedAmount}`\n}\n\nconsole.log(getFine(130, 300))\n",
        "answer": "通过方法 `Intl.NumberFormat`，我们可以格式化任意区域的数字值。我们对数字值 `130` 进行 `mile-per-hour` 作为 `unit` 的 `en-US` 区域 格式化，结果为 `130 mph`。对数字值 `300` 进行 `USD` 作为 `currentcy` 的 `en-US` 区域格式化，结果为 `$300.00`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: The driver drove 130 and has to pay 300"
            },
            {
                "key": "B",
                "value": "B: The driver drove 130 mph and has to pay $300.00"
            },
            {
                "key": "C",
                "value": "C: The driver drove undefined and has to pay undefined"
            },
            {
                "key": "D",
                "value": "D: The driver drove 130.00 and has to pay 300.00"
            }
        ]
    },
    {
        "id": 124,
        "title": "127. 输出什么？",
        "result": "答案: B",
        "code": "const spookyItems = [\"👻\", \"🎃\", \"🕸\"];\n({ item: spookyItems[3] } = { item: \"💀\" });\n\nconsole.log(spookyItems);\n",
        "answer": "通过解构对象们，我们可以从右手边的对象中拆出值，并且将拆出的值分配给左手边对象同名的属性。在这种情况下，我们将值 \"💀\" 分配给 `spookyItems[3]`。相当于我们正在篡改数组 `spookyItems`，我们给它添加了值 \"💀\"。当输出 `spookyItems` 时，结果为 `[\"👻\", \"🎃\", \"🕸\", \"💀\"]`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `[\"👻\", \"🎃\", \"🕸\"]`"
            },
            {
                "key": "B",
                "value": "B: `[\"👻\", \"🎃\", \"🕸\", \"💀\"]`"
            },
            {
                "key": "C",
                "value": "C: `[\"👻\", \"🎃\", \"🕸\", { item: \"💀\" }]`"
            },
            {
                "key": "D",
                "value": "D: `[\"👻\", \"🎃\", \"🕸\", \"[object Object]\"]`"
            }
        ]
    },
    {
        "id": 125,
        "title": "128. 输出什么？",
        "result": "答案: C",
        "code": "const name = \"Lydia Hallie\";\nconst age = 21;\n\nconsole.log(Number.isNaN(name));\nconsole.log(Number.isNaN(age));\n\nconsole.log(isNaN(name));\nconsole.log(isNaN(age));\n",
        "answer": "通过方法 `Number.isNaN`，你可以检测你传递的值是否为 **数字值** 并且是否等价于 `NaN`。`name` 不是一个数字值，因此 `Number.isNaN(name)` 返回 `false`。`age` 是一个数字值，但它不等价于 `NaN`，因此 `Number.isNaN(age)` 返回 `false`.\n通过方法 `isNaN`， 你可以检测你传递的值是否一个 number。`name` 不是一个 `number`，因此 `isNaN(name)` 返回 `true`. `age` 是一个 `number` 因此 `isNaN(age)` 返回 `false`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `true` `false` `true` `false`"
            },
            {
                "key": "B",
                "value": "B: `true` `false` `false` `false`"
            },
            {
                "key": "C",
                "value": "C: `false` `false` `true` `false`"
            },
            {
                "key": "D",
                "value": "D: `false` `true` `false` `true`"
            }
        ]
    },
    {
        "id": 126,
        "title": "129. 输出什么？",
        "result": "答案: D",
        "code": "const randomValue = 21;\n\nfunction getInfo() {\n\tconsole.log(typeof randomValue);\n\tconst randomValue = \"Lydia Hallie\";\n}\n\ngetInfo();\n",
        "answer": "通过 `const` 关键字声明的变量在被初始化之前不可被引用：这被称之为 **暂时性死区**。在函数 `getInfo` 中，变量 `randomValue` 声明在`getInfo` 的作用域的此法环境中。在想要对 `typeof randomValue` 进行 log 之前，变量 `randomValue` 仍未被初始化： 错误`ReferenceError` 被抛出！JS 引擎并不会根据作用域链网上寻找该变量，因为我们已经在 `getInfo` 函数中声明了 `randomValue` 变量。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `\"number\"`"
            },
            {
                "key": "B",
                "value": "B: `\"string\"`"
            },
            {
                "key": "C",
                "value": "C: `undefined`"
            },
            {
                "key": "D",
                "value": "D: `ReferenceError`"
            }
        ]
    },
    {
        "id": 127,
        "title": "130. 输出什么？",
        "result": "答案: C",
        "code": "const myPromise = Promise.resolve(\"Woah some cool data\");\n\n(async () => {\n\ttry {\n\t\tconsole.log(await myPromise);\n\t} catch {\n\t\tthrow new Error(`Oops didn't work`);\n\t} finally {\n\t\tconsole.log(\"Oh finally!\");\n\t}\n})();\n",
        "answer": "在 `try` 块区，我们打印 `myPromise` 变量的 awaited 值： `\"Woah some cool data\"`。因为`try` 块区没有错误抛出，`catch` 块区的代码并不执行。`finally` 块区的代码 **总是** 执行，`\"Oh finally!\"` 被输出。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `Woah some cool data`"
            },
            {
                "key": "B",
                "value": "B: `Oh finally!`"
            },
            {
                "key": "C",
                "value": "C: `Woah some cool data` `Oh finally!`"
            },
            {
                "key": "D",
                "value": "D: `Oops didn't work` `Oh finally!`"
            }
        ]
    },
    {
        "id": 128,
        "title": "131. 输出什么？",
        "result": "答案: B",
        "code": "const emojis = [\"🥑\", [\"✨\", \"✨\", [\"🍕\", \"🍕\"]]];\n\nconsole.log(emojis.flat(1));\n",
        "answer": "通过方法 `flat`， 我们可以创建一个新的，已被扁平化的数组。被扁平化的深度取决于我们传递的值。在这个 case 里，我们传递了值 `1` (并不必要，这是默认值)，相当于只有第一层的数组才会被连接。即这个 case 里的 `['🥑']` and `['✨', '✨', ['🍕', '🍕']]`。连接这两个数组得到结果 `['🥑', '✨', '✨', ['🍕', '🍕']]`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `['🥑', ['✨', '✨', ['🍕', '🍕']]]`"
            },
            {
                "key": "B",
                "value": "B: `['🥑', '✨', '✨', ['🍕', '🍕']]`"
            },
            {
                "key": "C",
                "value": "C: `['🥑', ['✨', '✨', '🍕', '🍕']]`"
            },
            {
                "key": "D",
                "value": "D: `['🥑', '✨', '✨', '🍕', '🍕']`"
            }
        ]
    },
    {
        "id": 129,
        "title": "<a name=20191224></a>132. 输出什么？",
        "result": "答案: D",
        "code": "class Counter {\n\tconstructor() {\n\t\tthis.count = 0;\n\t}\n\n\tincrement() {\n\t\tthis.count++;\n\t}\n}\n\nconst counterOne = new Counter();\ncounterOne.increment();\ncounterOne.increment();\n\nconst counterTwo = counterOne;\ncounterTwo.increment();\n\nconsole.log(counterOne.count);\n",
        "answer": "`counterOne` 是类 `Counter` 的一个实例。类 Counter 包含一个`count` 属性在它的构造函数里， 和一个 `increment` 方法。首先，我们通过 `counterOne.increment()` 调用方法 `increment` 两次。现在，`counterOne.count` 为 `2`.\n&lt;img src=\"https://i.imgur.com/KxLlTm9.png\" width=\"400\"&gt;\n然后，我们创建一个新的变量 `counterTwo` 并将 `counterOne` 的引用地址赋值给它。因为对象受引用地址的影响，我们刚刚创建了一个新的对象，其引用地址和 `counterOne` 的等价。因此它们指向同一块内存地址，任何对其的副作用都会影响 `counterTwo`。现在 `counterTwo.count` 为 `2`。\n我们调用 `counterTwo.increment()` 将 `count` 的值设为 `3`。然后，我们打印 `counterOne` 里的 count，结果为 `3`。\n&lt;img src=\"https://i.imgur.com/BNBHXmc.png\" width=\"400\"&gt;\n",
        "options": [
            {
                "key": "A",
                "value": "A: `0`"
            },
            {
                "key": "B",
                "value": "B: `1`"
            },
            {
                "key": "C",
                "value": "C: `2`"
            },
            {
                "key": "D",
                "value": "D: `3`"
            }
        ]
    },
    {
        "id": 130,
        "title": "133. 输出什么？",
        "result": "答案: D",
        "code": "const myPromise = Promise.resolve(Promise.resolve(\"Promise!\"));\n\nfunction funcOne() {\n\tmyPromise.then(res => res).then(res => console.log(res));\n\tsetTimeout(() => console.log(\"Timeout!\"), 0);\n\tconsole.log(\"Last line!\");\n}\n\nasync function funcTwo() {\n\tconst res = await myPromise;\n\tconsole.log(await res);\n\tsetTimeout(() => console.log(\"Timeout!\"), 0);\n\tconsole.log(\"Last line!\");\n}\n\nfuncOne();\nfuncTwo();\n",
        "answer": "首先，我们调用 `funcOne`。在函数 `funcOne` 的第一行，我们调用`myPromise` promise **异步操作**。当 JS 引擎在忙于执行 promise，它继续执行函数 `funcOne`。下一行 **异步操作** `setTimeout`，其回调函数被 Web API 调用。 (详情请参考我关于 event loop 的文章.)\npromise 和 timeout 都是异步操作，函数继续执行当 JS 引擎忙于执行 promise 和 处理 `setTimeout` 的回调。相当于 `Last line!` 首先被输出， 因为它不是异步操作。执行完 `funcOne` 的最后一行，promise 状态转变为 resolved，`Promise!` 被打印。然而，因为我们调用了 `funcTwo()`，调用栈不为空，`setTimeout` 的回调仍不能入栈。\n我们现在处于 `funcTwo`，先 **awaiting** myPromise。通过 `await` 关键字， 我们暂停了函数的执行直到 promise 状态变为 resolved (或 rejected)。然后，我们输出 `res` 的 awaited 值（因为 promise 本身返回一个 promise）。 接着输出 `Promise!`。\n下一行就是 **异步操作** `setTimeout`，其回调函数被 Web API 调用。\n我们执行到函数 `funcTwo` 的最后一行，输出 `Last line!`。现在，因为 `funcTwo` 出栈，调用栈为空。在事件队列中等待的回调函数（`() =&gt; console.log(\"Timeout!\")` from `funcOne`, and `() =&gt; console.log(\"Timeout!\")` from `funcTwo`）以此入栈。第一个回调输出 `Timeout!`，并出栈。然后，第二个回调输出 `Timeout!`，并出栈。得到结果 `Last line! Promise! Promise! Last line! Timeout! Timeout!`\n",
        "options": [
            {
                "key": "A",
                "value": "A: `Promise! Last line! Promise! Last line! Last line! Promise!`"
            },
            {
                "key": "B",
                "value": "B: `Last line! Timeout! Promise! Last line! Timeout! Promise!`"
            },
            {
                "key": "C",
                "value": "C: `Promise! Last line! Last line! Promise! Timeout! Timeout!`"
            },
            {
                "key": "D",
                "value": "D: `Last line! Promise! Promise! Last line! Timeout! Timeout!`"
            }
        ]
    },
    {
        "id": 131,
        "title": "134. 我们怎样才能在 index.js 中调用 sum.js? 中的 sum？",
        "result": "答案: C",
        "code": "// sum.js\nexport default function sum(x) {\n\treturn x + x;\n}\n\n// index.js\nimport * as sum from \"./sum\";\n// info.js\nexport const name = \"Lydia\";\nexport const age = 21;\nexport default \"I love JavaScript\";\n\n// index.js\nimport * as info from \"./info\";\nconsole.log(info);\n{\n  default: \"I love JavaScript\",\n  name: \"Lydia\",\n  age: 21\n}\n{ default: function sum(x) { return x + x } }\n",
        "answer": "使用符号 `*`，我们引入文件中的所有值，包括默认和具名。如果我们有以下文件：\n将会输出以下内容：\n以 `sum` 为例，相当于以下形式引入值 `sum`：\n我们可以通过调用 `sum.default` 来调用该函数\n",
        "options": [
            {
                "key": "A",
                "value": "A: `sum(4)`"
            },
            {
                "key": "B",
                "value": "B: `sum.sum(4)`"
            },
            {
                "key": "C",
                "value": "C: `sum.default(4)`"
            },
            {
                "key": "D",
                "value": "D: 默认导出不用 `*` 来导入，只能具名导出"
            }
        ]
    },
    {
        "id": 132,
        "title": "135. 输出什么？",
        "result": "答案: C",
        "code": "const handler = {\n\tset: () => console.log(\"Added a new property!\"),\n\tget: () => console.log(\"Accessed a property!\")\n};\n\nconst person = new Proxy({}, handler);\n\nperson.name = \"Lydia\";\nperson.name;\n",
        "answer": "使用 Proxy 对象，我们可以给一个对象添加自定义行为。在这个 case，我们传递一个包含以下属性的对象 `handler` : `set` and `get`。每当我们 **设置** 属性值时 `set` 被调用，每当我们 **获取** 时 `get` 被调用。\n第一个参数是一个空对象 `{}`，作为 `person` 的值。对于这个对象，自定义行为被定义在对象 `handler`。如果我们向对象 `person` 添加属性，`set` 将被调用。如果我们获取 `person` 的属性，`get` 将被调用。\n首先，我们向 proxy 对象 (`person.name = \"Lydia\"`) 添加一个属性 `name`。`set` 被调用并输出 `\"Added a new property!\"`。\n然后，我们获取 proxy 对象的一个属性，对象 handler 的属性 `get` 被调用。输出 `\"Accessed a property!\"`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `Added a new property!`"
            },
            {
                "key": "B",
                "value": "B: `Accessed a property!`"
            },
            {
                "key": "C",
                "value": "C: `Added a new property!` `Accessed a property!`"
            },
            {
                "key": "D",
                "value": "D: 没有任何输出"
            }
        ]
    },
    {
        "id": 133,
        "title": "136. 以下哪一项会对对象 person 有副作用？",
        "result": "答案: A",
        "code": "const person = { name: \"Lydia Hallie\" };\n\nObject.seal(person);\n",
        "answer": "使用 `Object.seal` 我们可以防止新属性 **被添加**，或者存在属性 **被移除**.\n然而，你仍然可以对存在属性进行更改。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `person.name = \"Evan Bacon\"`"
            },
            {
                "key": "B",
                "value": "B: `person.age = 21`"
            },
            {
                "key": "C",
                "value": "C: `delete person.name`"
            },
            {
                "key": "D",
                "value": "D: `Object.assign(person, { age: 21 })`"
            }
        ]
    },
    {
        "id": 134,
        "title": "137. 以下哪一项会对对象 person 有副作用？",
        "result": "答案: C",
        "code": "const person = {\n\tname: \"Lydia Hallie\",\n\taddress: {\n\t\tstreet: \"100 Main St\"\n\t}\n};\n\nObject.freeze(person);\n",
        "answer": "使用方法 `Object.freeze` 对一个对象进行 **冻结**。不能对属性进行添加，修改，删除。\n然而，它仅 对对象进行 **浅** 冻结，意味着只有 对象中的 **直接** 属性被冻结。如果属性是另一个 object，像案例中的 `address`，`address` 中的属性没有被冻结，仍然可以被修改。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `person.name = \"Evan Bacon\"`"
            },
            {
                "key": "B",
                "value": "B: `delete person.address`"
            },
            {
                "key": "C",
                "value": "C: `person.address.street = \"101 Main St\"`"
            },
            {
                "key": "D",
                "value": "D: `person.pet = { name: \"Mara\" }`"
            }
        ]
    },
    {
        "id": 135,
        "title": "138. 输出什么？",
        "result": "答案: A",
        "code": "const add = x => x + x;\n\nfunction myFunc(num = 2, value = add(num)) {\n\tconsole.log(num, value);\n}\n\nmyFunc();\nmyFunc(3);\n",
        "answer": "首先我们不传递任何参数调用 `myFunc()`。因为我们没有传递参数，`num` 和 `value` 获取它们各自的默认值：num 为 `2`，而 `value` 为函数 `add` 的返回值。对于函数 `add`，我们传递值为 2 的 `num` 作为参数。函数 `add` 返回 `4` 作为 `value` 的值。\n然后，我们调用 `myFunc(3)` 并传递值 `3` 参数 `num` 的值。我们没有给 `value` 传递值。因为我们没有给参数 `value` 传递值，它获取默认值：函数 `add` 的返回值。对于函数 `add`，我们传递值为 3 的 `num`给它。函数 `add` 返回 `6` 作为 `value` 的值。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `2` `4` and `3` `6`"
            },
            {
                "key": "B",
                "value": "B: `2` `NaN` and `3` `NaN`"
            },
            {
                "key": "C",
                "value": "C: `2` `Error` and `3` `6`"
            },
            {
                "key": "D",
                "value": "D: `2` `4` and `3` `Error`"
            }
        ]
    },
    {
        "id": 136,
        "title": "139. 输出什么？",
        "result": "答案: D",
        "code": "class Counter {\n  #number = 10\n\n  increment() {\n    this.#number++\n  }\n\n  getNum() {\n    return this.#number\n  }\n}\n\nconst counter = new Counter()\ncounter.increment()\n\nconsole.log(counter.#number)\n",
        "answer": "在 ES2020 中，通过 `#` 我们可以给 class 添加私有变量。在 class 的外部我们无法获取该值。当我们尝试输出 `counter.#number`，语法错误被抛出：我们无法在 class `Counter` 外部获取它！\n",
        "options": [
            {
                "key": "A",
                "value": "A: `10`"
            },
            {
                "key": "B",
                "value": "B: `11`"
            },
            {
                "key": "C",
                "value": "C: `undefined`"
            },
            {
                "key": "D",
                "value": "D: `SyntaxError`"
            }
        ]
    },
    {
        "id": 137,
        "title": "140. 选择哪一个？",
        "result": "答案: B",
        "code": "const teams = [\n\t{ name: \"Team 1\", members: [\"Paul\", \"Lisa\"] },\n\t{ name: \"Team 2\", members: [\"Laura\", \"Tim\"] }\n];\n\nfunction* getMembers(members) {\n\tfor (let i = 0; i < members.length; i++) {\n\t\tyield members[i];\n\t}\n}\n\nfunction* getTeams(teams) {\n\tfor (let i = 0; i < teams.length; i++) {\n\t\t// ✨ SOMETHING IS MISSING HERE ✨\n\t}\n}\n\nconst obj = getTeams(teams);\nobj.next(); // { value: \"Paul\", done: false }\nobj.next(); // { value: \"Lisa\", done: false }\n",
        "answer": "为了遍历 `teams` 数组中对象的属性 `members` 中的每一项，我们需要将 `teams[i].members` 传递给 Generator 函数 `getMembers`。Generator 函数返回一个 generator 对象。为了遍历这个 generator 对象中的每一项，我们需要使用 `yield*`.\n如果我们没有写 `yield`，`return yield` 或者 `return`，整个 Generator 函数不会第一时间 return 当我们调用 `next` 方法。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `yield getMembers(teams[i].members)`"
            },
            {
                "key": "B",
                "value": "B: `yield* getMembers(teams[i].members)`"
            },
            {
                "key": "C",
                "value": "C: `return getMembers(teams[i].members)`"
            },
            {
                "key": "D",
                "value": "D: `return yield getMembers(teams[i].members)`"
            }
        ]
    },
    {
        "id": 138,
        "title": "141. 输出什么？",
        "result": "答案: C",
        "code": "const person = {\n\tname: \"Lydia Hallie\",\n\thobbies: [\"coding\"]\n};\n\nfunction addHobby(hobby, hobbies = person.hobbies) {\n\thobbies.push(hobby);\n\treturn hobbies;\n}\n\naddHobby(\"running\", []);\naddHobby(\"dancing\");\naddHobby(\"baking\", person.hobbies);\n\nconsole.log(person.hobbies);\n",
        "answer": "函数 `addHobby` 接受两个参数，`hobby` 和有着对象 `person` 中数组 `hobbies` 默认值的 `hobbies`。\n首相，我们调用函数 `addHobby`，并给 `hobby` 传递 `\"running\"` 以及给 `hobbies` 传递一个空数组。因为我们给 `hobbies` 传递了空数组，`\"running\"` 被添加到这个空数组。\n然后，我们调用函数 `addHobby`，并给 `hobby` 传递 `\"dancing\"`。我们不向 `hobbies` 传递值，因此它获取其默认值 —— 对象 `person` 的 属性 `hobbies`。我们向数组 `person.hobbies` push `dancing`。\n最后，我们调用函数 `addHobby`，并向 `hobby` 传递 值 `\"bdaking\"`，并且向 `hobbies` 传递 `person.hobbies`。我们向数组 `person.hobbies` push `dancing`。\npushing `dancing` 和 `baking` 之后，`person.hobbies` 的值为 `[\"coding\", \"dancing\", \"baking\"]`\n",
        "options": [
            {
                "key": "A",
                "value": "A: `[\"coding\"]`"
            },
            {
                "key": "B",
                "value": "B: `[\"coding\", \"dancing\"]`"
            },
            {
                "key": "C",
                "value": "C: `[\"coding\", \"dancing\", \"baking\"]`"
            },
            {
                "key": "D",
                "value": "D: `[\"coding\", \"running\", \"dancing\", \"baking\"]`"
            }
        ]
    },
    {
        "id": 139,
        "title": "142. 输出什么？",
        "result": "答案: B",
        "code": "class Bird {\n\tconstructor() {\n\t\tconsole.log(\"I'm a bird. 🦢\");\n\t}\n}\n\nclass Flamingo extends Bird {\n\tconstructor() {\n\t\tconsole.log(\"I'm pink. 🌸\");\n\t\tsuper();\n\t}\n}\n\nconst pet = new Flamingo();\n",
        "answer": "我们创建了类 `Flamingo` 的实例 `pet`。当我们实例化这个实例，`Flamingo` 中的 `constructor` 被调用。首相，输出 `\"I'm pink. 🌸\"`，之后我们调用`super()`。`super()` 调用父类的构造函数，`Bird`。`Bird` 的构造函数被调用，并输出 `\"I'm a bird. 🦢\"`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `I'm pink. 🌸`"
            },
            {
                "key": "B",
                "value": "B: `I'm pink. 🌸` `I'm a bird. 🦢`"
            },
            {
                "key": "C",
                "value": "C: `I'm a bird. 🦢` `I'm pink. 🌸`"
            },
            {
                "key": "D",
                "value": "D: Nothing, we didn't call any method"
            }
        ]
    },
    {
        "id": 140,
        "title": "143. 哪一个选项会导致报错？",
        "result": "答案: D",
        "code": "const emojis = [\"🎄\", \"🎅🏼\", \"🎁\", \"⭐\"];\n\n/* 1 */ emojis.push(\"🦌\");\n/* 2 */ emojis.splice(0, 2);\n/* 3 */ emojis = [...emojis, \"🥂\"];\n/* 4 */ emojis.length = 0;\n",
        "answer": "`const` 关键字意味着我们不能 **重定义** 变量中的值，它 **仅可读**。而然，值本身不可修改。数组 `emojis` 中的值可被修改，如 push 新的值，拼接，又或者将数组的长度设置为 0。\n",
        "options": [
            {
                "key": "A",
                "value": "A: 1"
            },
            {
                "key": "B",
                "value": "B: 1 and 2"
            },
            {
                "key": "C",
                "value": "C: 3 and 4"
            },
            {
                "key": "D",
                "value": "D: 3"
            }
        ]
    },
    {
        "id": 141,
        "title": "144. 我们需要向对象 person 添加什么，以致执行 [...person] 时获得形如 [\"Lydia Hallie\", 21] 的输出？",
        "result": "答案: C",
        "code": "const person = {\n  name: \"Lydia Hallie\",\n  age: 21\n}\n\n[...person] // [\"Lydia Hallie\", 21]\n",
        "answer": "对象默认并不是可迭代的。如果迭代规则被定义，则一个对象是可迭代的（An iterable is an iterable if the iterator protocol is present）。我们可以通过添加迭代器 symbol `[Symbol.iterator]` 来定义迭代规则，其返回一个 generator 对象，比如说构建一个 generator 函数 `*[Symbol.iterator]() {}`。如果我们想要返回数组 `[\"Lydia Hallie\", 21]`: `yield* Object.values(this)`，这个 generator 函数一定要 yield 对象 `person` 的`Object.values`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: 不需要，对象默认就是可迭代的"
            },
            {
                "key": "B",
                "value": "B: `*[Symbol.iterator]() { for (let x in this) yield* this[x] }`"
            },
            {
                "key": "C",
                "value": "C: `*[Symbol.iterator]() { yield* Object.values(this) }`"
            },
            {
                "key": "D",
                "value": "D: `*[Symbol.iterator]() { for (let x in this) yield this }`"
            }
        ]
    },
    {
        "id": 142,
        "title": "145. 输出什么？",
        "result": "答案: C",
        "code": "let count = 0;\nconst nums = [0, 1, 2, 3];\n\nnums.forEach(num => {\n\tif (num) count += 1\n})\n\nconsole.log(count)\n",
        "answer": "在 `forEach` 循环内部的 `if` 会判断 `num` 的值是 truthy 或者是 falsy。因为 `nums` 数组的第一个数字是 `0`，一个 falsy 值， `if` 语句代码块不会被执行。`count` 仅仅在 `nums` 数组的其他 3 个数字 `1`，`2`，`3` 时加 1。因为 `count` 执行了 3 次加 `1` 运算，所以 `count` 的值为 `3`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: 1"
            },
            {
                "key": "B",
                "value": "B: 2"
            },
            {
                "key": "C",
                "value": "C: 3"
            },
            {
                "key": "D",
                "value": "D: 4"
            }
        ]
    },
    {
        "id": 143,
        "title": "146. 输出是什么？",
        "result": "答案: D",
        "code": "function getFruit(fruits) {\n\tconsole.log(fruits?.[1]?.[1])\n}\n\ngetFruit([['🍊', '🍌'], ['🍍']])\ngetFruit()\ngetFruit([['🍍'], ['🍊', '🍌']])\n",
        "answer": "`?` 允许我们去选择性地访问对象内部更深层的嵌套属性。 我们尝试打印 `fruits` 数组索引值为 `1` 的子数组内部的索引值为 `1` 的元素。 如果在 `fruits` 数组索引值 为 `1` 的位置不存在元素，会直接返回 `undefined`。 如果 `fruits` 数组在索引值为 `1` 的位置存在元素，但是子数组在索引值为 `1` 的位置不存在元素，也会返回 `undefined`。\n首先，我们尝试打印 `[['🍊', '🍌'], ['🍍']]` 的子数组 `['🍍']` 的第 2 个元素。这个子数组只包含一个元素，也就意味着在索引值为 `1` 的位置不存在元素，所以返回的是 `undefined` 。\n其次，我们在没有传入任何参数调用了 `getFruits` 函数，也就意味着形参 `fruits` 的默认值为`undefined`。因为我们选择性地链接了 `fruits` 在索引值为 `1` 的元素，因为在索引值为 `1` 的位置不存在元素，因此返回的是 `undefined` 。\n最后，我们尝试打印 `['🍍'], ['🍊', '🍌']` 的子数组 `['🍊', '🍌']` 的第 2 个元素。子数组索引值为 `1`的位置为 `🍌` ，因此它被打印出了。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `null`, `undefined`, 🍌"
            },
            {
                "key": "B",
                "value": "B: `[]`, `null`, 🍌"
            },
            {
                "key": "C",
                "value": "C: `[]`, `[]`, 🍌"
            },
            {
                "key": "D",
                "value": "D: `undefined`, `undefined`, 🍌"
            }
        ]
    },
    {
        "id": 144,
        "title": "147. 输出什么？",
        "result": "答案: A",
        "code": "class Calc {\n\tconstructor() {\n\t\tthis.count = 0 \n\t}\n\n\tincrease() {\n\t\tthis.count ++\n\t}\n}\n\nconst calc = new Calc()\nnew Calc().increase()\n\nconsole.log(calc.count)\n",
        "answer": "我们设置 `calc` 变量为 `Calc` 类的一个新实例。 然后，我们初始化一个 `Calc` 的新实例，而且调用了这个实例的 `increase` 方法。因为 count 属性是在 `Calc` class 的 constructor 内部的，所以 count 属性不会在 `Calc` 的原型链上共享出去。这就意味着 calc 实例的 count 值不会被更新，count 仍然是 `0`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `0`"
            },
            {
                "key": "B",
                "value": "B: `1`"
            },
            {
                "key": "C",
                "value": "C: `undefined`"
            },
            {
                "key": "D",
                "value": "D: `ReferenceError`"
            }
        ]
    },
    {
        "id": 145,
        "title": "148. 输出什么？",
        "result": "答案: B",
        "code": "const user = {\n\temail: \"e@mail.com\",\n\tpassword: \"12345\"\n}\n\nconst updateUser = ({ email, password }) => {\n\tif (email) {\n\t\tObject.assign(user, { email })\n\t}\n\n\tif (password) {\n\t\tuser.password = password\n\t}\n\n\treturn user\n}\n\nconst updatedUser = updateUser({ email: \"new@email.com\" })\n\nconsole.log(updatedUser === user)\n",
        "answer": "`updateUser` 函数更新 user 的 `email` 和 `password` 属性的值， 如果它们的值传入函数， 函数返回的就是 `user` 对象。 `updateUser` 函数的返回值是 `user` 对象，意味着 updatedUser 的值与 `user` 指向的是同一个 `user` 对象。`updatedUser === user` 为 `true`.\n",
        "options": [
            {
                "key": "A",
                "value": "A: `false`"
            },
            {
                "key": "B",
                "value": "B: `true`"
            },
            {
                "key": "C",
                "value": "C: `TypeError`"
            },
            {
                "key": "D",
                "value": "D: `ReferenceError`"
            }
        ]
    },
    {
        "id": 146,
        "title": "149. 输出什么？",
        "result": "答案: C",
        "code": "const fruit = ['🍌', '🍊', '🍎']\n\nfruit.slice(0, 1)\nfruit.splice(0, 1)\nfruit.unshift('🍇')\n\nconsole.log(fruit)\n",
        "answer": "首先，我们在 fruit 数组上调用 `slice` 方法。 slice 方法不会修改原始数组，但是会返回从数组切片下来的值：香蕉 emoji。\n其次，我们在 fruit 数组上调用 `splice` 方法。 splice 方法会修改原始数组，也就意味着 fruit 数组此时为 `['🍊', '🍎']`。\n最后，我们在 fruit 数组上调用 `unshift` 方法，通过添加一个值的方式改变了原始数组，添加的是'🍇'，它成为了数组的第一个元素。现在 fruit 数组的组成为 `['🍇', '🍊', '🍎']`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `['🍌', '🍊', '🍎']`"
            },
            {
                "key": "B",
                "value": "B: `['🍊', '🍎']`"
            },
            {
                "key": "C",
                "value": "C: `['🍇', '🍊', '🍎']`"
            },
            {
                "key": "D",
                "value": "D: `['🍇', '🍌', '🍊', '🍎']`"
            }
        ]
    },
    {
        "id": 147,
        "title": "150. 输出什么？",
        "result": "答案: B",
        "code": "const animals = {};\nlet dog = { emoji: '🐶' }\nlet cat = { emoji: '🐈' }\n\nanimals[dog] = { ...dog, name: \"Mara\" }\nanimals[cat] = { ...cat, name: \"Sara\" }\n\nconsole.log(animals[dog])\n",
        "answer": "对象的键会被转换为字符串。\n因为  `dog` 的值是一个对象，   `animals[dog]` 实际上意味着我们创建了一个叫做 `\"object Object\"` 的属性来代表新的对象。  `animals[\"object Object\"]` 现在等于 `{ emoji: \"🐶\", name: \"Mara\"}`。\n`cat` 也是一个对象，`animals[cat]` 实际上意味着我们在用新的 cat 的属性覆盖  `animals[``\"``object Object``\"``]` 的值。\n打印  `animals[dog]`，实际上是`animals[\"object Object\"]`，这是因为转化`dog`对象为一个字符串结果 `\"object Object\"` ，所以返回 `{ emoji: \"🐈\", name: \"Sara\" }`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `{ emoji: \"🐶\", name: \"Mara\" }`"
            },
            {
                "key": "B",
                "value": "B: `{ emoji: \"🐈\", name: \"Sara\" }`"
            },
            {
                "key": "C",
                "value": "C: `undefined`"
            },
            {
                "key": "D",
                "value": "D: `ReferenceError`"
            }
        ]
    },
    {
        "id": 148,
        "title": "151. 输出什么？",
        "result": "答案: A",
        "code": "const user = {\n\temail: \"my@email.com\",\n\tupdateEmail: email => {\n\t\tthis.email = email\n\t}\n}\n\nuser.updateEmail(\"new@email.com\")\nconsole.log(user.email)\n",
        "answer": "`updateEmail` 函数是一个箭头函数，它没有和 `user` 对象绑定。这就意味着 `this` 关键字不会引用到 `user` 对象，但是会引用到全局对象。 `user` 对象内部的 `email` 的值不会更新。当打印 `user.email` 的时候， 原始值 `my@email.com` 被返回。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `my@email.com`"
            },
            {
                "key": "B",
                "value": "B: `new@email.com`"
            },
            {
                "key": "C",
                "value": "C: `undefined`"
            },
            {
                "key": "D",
                "value": "D: `ReferenceError`"
            }
        ]
    },
    {
        "id": 149,
        "title": "152. 输出什么？",
        "result": "答案: D",
        "code": "const promise1 = Promise.resolve('First')\nconst promise2 = Promise.resolve('Second')\nconst promise3 = Promise.reject('Third')\nconst promise4 = Promise.resolve('Fourth')\n\nconst runPromises = async () => {\n\tconst res1 = await Promise.all([promise1, promise2])\n\tconst res2  = await Promise.all([promise3, promise4])\n\treturn [res1, res2]\n}\n\nrunPromises()\n\t.then(res => console.log(res))\n\t.catch(err => console.log(err))\n",
        "answer": "`Promise.all` 方法可以并行式运行 promise。如果其中一个 promise 失败了，`Promise.all` 方法会带上被 reject 的 promise 的值_rejects_。在这个例子中， `promise3` 带着 `\"Third\"` 值 reject。我们在调用 `runPromises` 时在 `runPromises` 函数内部的 `catch` 方法去捕获任意 error 从而捕获到被 reject 的值。因为 `promise3` 带着 `\"Third\"` 被 reject，所以只有 `\"Third\"` 打印。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `[['First', 'Second'], ['Fourth']]`"
            },
            {
                "key": "B",
                "value": "B: `[['First', 'Second'], ['Third', 'Fourth']]`"
            },
            {
                "key": "C",
                "value": "C: `[['First', 'Second']]`"
            },
            {
                "key": "D",
                "value": "D: `'Third'`"
            }
        ]
    },
    {
        "id": 150,
        "title": "153. 哪个作为method的值可以打印{ name: \"Lydia\", age: 22 }?",
        "result": "答案: C",
        "code": "const keys = [\"name\", \"age\"]\nconst values = [\"Lydia\", 22]\n\nconst method = /* ?? */\nObject[method](keys.map((_, i) => {\n\treturn [keys[i], values[i]]\n})) // { name: \"Lydia\", age: 22 }\n",
        "answer": "`fromEntries` 方法可以将二维数组转换为对象。在每个子数组的第一个元素是 key，在每个子数组的第二个元素是 value。在这个例子中，我们映射了 `keys` 数组，它返回了一个数组，数组的第一个元素为 keys 数组当前索引的值，第二个元素为 values 数组当前索引的值。\n这样就创建了一个包含正确 keys 和 values 的子数组的数组，因此结果为`{ name: \"Lydia\", age: 22 }`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `entries`"
            },
            {
                "key": "B",
                "value": "B: `values`"
            },
            {
                "key": "C",
                "value": "C: `fromEntries`"
            },
            {
                "key": "D",
                "value": "D: `forEach`"
            }
        ]
    },
    {
        "id": 151,
        "title": "154. 输出什么？",
        "result": "答案: C",
        "code": "const createMember = ({ email, address = {}}) => {\n\tconst validEmail = /.+\\@.+\\..+/.test(email)\n\tif (!validEmail) throw new Error(\"Valid email pls\")\n\n\treturn {\n\t\temail,\n\t\taddress: address ? address : null\n\t}\n}\n\nconst member = createMember({ email: \"my@email.com\" })\nconsole.log(member)\n",
        "answer": "`address` 的默认值是一个空对象 `{}`。当我们设置 `member` 变量为 `createMember` 函数返回的对象，我们没有为 address 参数传值，意味着 address 的值为默认的空对象 `{}`。一个空对象是一个 truthy 值，意味着 `address ? address : null` 条件会返回 `true`。address 的值为空对象 `{}`。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `{ email: \"my@email.com\", address: null }`"
            },
            {
                "key": "B",
                "value": "B: `{ email: \"my@email.com\" }`"
            },
            {
                "key": "C",
                "value": "C: `{ email: \"my@email.com\", address: {} }`"
            },
            {
                "key": "D",
                "value": "D: `{ email: \"my@email.com\", address: undefined }`"
            }
        ]
    },
    {
        "id": 152,
        "title": "155. 输出什么？",
        "result": "答案: B",
        "code": "let randomValue = { name: \"Lydia\" }\nrandomValue = 23\n\nif (!typeof randomValue === \"string\") {\n\tconsole.log(\"It's not a string!\")\n} else {\n\tconsole.log(\"Yay it's a string!\")\n}\n",
        "answer": "`if` 语句的条件判断 `!typeof randomValue` 的值是否等于 `\"string\"`。 `!` 操作符将这个值转化为一个布尔值。如果值是 truthy 的话，返回值会是 `false`，如果值是 falsy，返回值会是 `true`。在这里， `typeof randomValue` 的返回值是一个 truthy 值 `\"number\"`，意味着 `!typeof randomValue` 的值是一个布尔值 `false`。\n`!typeof randomValue === \"string\"` 总是返回 false，因为我们实际上是在执行 `false === \"string\"`。因为条件返回的是 `false`，所以 `else` 语句中的代码块会被运行，因此打印 `Yay it's a string!` 。\n",
        "options": [
            {
                "key": "A",
                "value": "A: `It's not a string!`"
            },
            {
                "key": "B",
                "value": "B: `Yay it's a string!`"
            },
            {
                "key": "C",
                "value": "C: `TypeError`"
            },
            {
                "key": "D",
                "value": "D: `undefined`"
            }
        ]
    }
]